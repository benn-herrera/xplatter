package gen

import (
	"strings"
	"testing"
)

// checkWASMRules asserts that the shared cmake/Emscripten WASM build rule is present.
// Called by both C and C++ Makefile generator tests.
func checkWASMRules(t *testing.T, content string) {
	t.Helper()
	if !strings.Contains(content, "cmake") {
		t.Error("missing cmake in WASM rules")
	}
	if !strings.Contains(content, "EMSCRIPTEN_TOOLCHAIN") {
		t.Error("missing EMSCRIPTEN_TOOLCHAIN in WASM rules")
	}
	if !strings.Contains(content, `-G "Unix Makefiles"`) {
		t.Error(`missing -G "Unix Makefiles" in cmake configure (required on Windows to avoid MSVC generator)`)
	}
}

func TestComputeWASMExports_Minimal(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	exports := ComputeWASMExports(ctx.API.API.Name, ctx.API)

	if !strings.HasPrefix(exports, "[") || !strings.HasSuffix(exports, "]") {
		t.Errorf("expected JSON array, got %q", exports)
	}

	expected := []string{
		`"_malloc"`,
		`"_free"`,
		`"_test_api_lifecycle_create_engine"`,
		`"_test_api_lifecycle_destroy_engine"`,
	}
	for _, e := range expected {
		if !strings.Contains(exports, e) {
			t.Errorf("missing export %s in %s", e, exports)
		}
	}
}

func TestComputeWASMExports_Full(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	exports := ComputeWASMExports(ctx.API.API.Name, ctx.API)

	expected := []string{
		`"_malloc"`,
		`"_free"`,
		`"_example_app_engine_lifecycle_create_engine"`,
		`"_example_app_engine_renderer_create_renderer"`,
		`"_example_app_engine_texture_load_texture_from_path"`,
	}
	for _, e := range expected {
		if !strings.Contains(exports, e) {
			t.Errorf("missing export %s", e)
		}
	}
}

func TestAPIDefRelPath(t *testing.T) {
	// API def relative to project root (parent of output dir)
	ctx := &Context{
		OutputDir:  "/home/user/project/generated",
		APIDefPath: "/home/user/project/api.yaml",
	}
	rel := APIDefRelPath(ctx)
	if rel != "api.yaml" {
		t.Errorf("expected api.yaml, got %q", rel)
	}

	// API def in a sibling directory
	ctx2 := &Context{
		OutputDir:  "/home/user/project/generated",
		APIDefPath: "/home/user/schemas/api.yaml",
	}
	rel2 := APIDefRelPath(ctx2)
	if rel2 != "../schemas/api.yaml" {
		t.Errorf("expected ../schemas/api.yaml, got %q", rel2)
	}
}

func TestMakefileHeader(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	var b strings.Builder
	MakefileHeader(&b, ctx, "cpp")
	content := b.String()

	if !strings.Contains(content, "API_NAME  := test_api") {
		t.Error("missing API_NAME variable")
	}
	if !strings.Contains(content, "LIB_NAME  := libtest_api") {
		t.Error("missing LIB_NAME variable")
	}
	if !strings.Contains(content, "PASCAL_NAME := TestApi") {
		t.Error("missing PASCAL_NAME variable")
	}
	if !strings.Contains(content, "IMPL_LANG := cpp") {
		t.Error("missing IMPL_LANG variable")
	}
	if !strings.Contains(content, "Generated by xplatter") {
		t.Error("missing generated file header")
	}
}

func TestMakefileTargetConfig(t *testing.T) {
	var b strings.Builder
	MakefileTargetConfig(&b)
	content := b.String()

	if !strings.Contains(content, "TARGETS ?= ios android web desktop") {
		t.Error("missing TARGETS variable")
	}
	if !strings.Contains(content, "target_enabled") {
		t.Error("missing target_enabled function")
	}
	if !strings.Contains(content, "ANDROID_SDK") {
		t.Error("missing NDK configuration")
	}
	if !strings.Contains(content, "IOS_MIN") {
		t.Error("missing iOS configuration")
	}
	if !strings.Contains(content, "EMSCRIPTEN_TOOLCHAIN") {
		t.Error("missing Emscripten configuration")
	}
	if !strings.Contains(content, "EMSCRIPTEN_ROOT") {
		t.Error("missing EMSCRIPTEN_ROOT intermediate variable")
	}
	if !strings.Contains(content, "em-config EMSCRIPTEN_ROOT") {
		t.Error("missing em-config EMSCRIPTEN_ROOT for macOS/Linux package installs")
	}

	// Windows platform detection
	if !strings.Contains(content, "findstring MINGW,$(HOST_OS)") {
		t.Error("missing MINGW detection for Windows")
	}
	if !strings.Contains(content, "findstring MSYS,$(HOST_OS)") {
		t.Error("missing MSYS detection for Windows")
	}
	if !strings.Contains(content, "DYLIB_EXT     := dll") {
		t.Error("missing dll extension for Windows")
	}
	if !strings.Contains(content, "EXE           := .exe") {
		t.Error("missing EXE variable for Windows")
	}
	if !strings.Contains(content, "NDK_HOST_OS   := windows") {
		t.Error("missing NDK_HOST_OS windows")
	}
	if !strings.Contains(content, "EXE       :=") {
		t.Error("missing EXE default (empty) initialization")
	}

	// MSVC discovery (Windows only)
	if !strings.Contains(content, "VSWHERE") {
		t.Error("missing VSWHERE for MSVC discovery")
	}
	if !strings.Contains(content, "MSVC_DIR") {
		t.Error("missing MSVC_DIR variable")
	}
	if !strings.Contains(content, "WIN_SDK_ROOT") {
		t.Error("missing WIN_SDK_ROOT for Windows SDK")
	}
	if !strings.Contains(content, "export INCLUDE") {
		t.Error("missing INCLUDE export for MSVC")
	}
	if !strings.Contains(content, "export LIB") {
		t.Error("missing LIB export for MSVC")
	}
}

func TestMakefileBindingVars(t *testing.T) {
	var b strings.Builder
	MakefileBindingVars(&b, "test_api", "generated/")
	content := b.String()

	if !strings.Contains(content, "GEN_DIR            := generated/") {
		t.Error("missing GEN_DIR variable with prefix")
	}
	if !strings.Contains(content, "GEN_HEADER         := $(GEN_DIR)$(API_NAME).h") {
		t.Error("missing GEN_HEADER using $(GEN_DIR)")
	}
	if !strings.Contains(content, "GEN_SWIFT_BINDING  := $(GEN_DIR)TestApi.swift") {
		t.Error("missing GEN_SWIFT_BINDING using $(GEN_DIR)")
	}

	// Test without prefix
	var b2 strings.Builder
	MakefileBindingVars(&b2, "test_api", "")
	content2 := b2.String()
	if !strings.Contains(content2, "GEN_DIR            := \n") {
		t.Error("missing empty GEN_DIR for no-prefix case")
	}
	if !strings.Contains(content2, "GEN_HEADER         := $(GEN_DIR)$(API_NAME).h") {
		t.Error("missing GEN_HEADER without prefix")
	}
}

func TestMakefileCodegenStamp(t *testing.T) {
	var b strings.Builder
	MakefileCodegenStamp(&b, "rust", "-o .")
	content := b.String()

	if !strings.Contains(content, "$(XPLATTER) generate --impl-lang rust -o .") {
		t.Error("missing codegen stamp rule with correct impl-lang and output flag")
	}
	if !strings.Contains(content, "$(STAMP): $(API_DEF)") {
		t.Error("missing STAMP dependency on API_DEF")
	}
}

func TestMakefilePackageIOS_StubTarget(t *testing.T) {
	var b strings.Builder
	MakefilePackageIOS(&b, func(b *strings.Builder) {
		b.WriteString("# test build arch rule\n\n")
	})
	content := b.String()

	// Verify the Darwin conditional exists
	if !strings.Contains(content, "ifeq ($(HOST_OS),Darwin)") {
		t.Error("missing HOST_OS Darwin conditional")
	}

	// Verify the else clause with stub target exists
	if !strings.Contains(content, "skipping iOS packaging on $(HOST_OS)") {
		t.Error("missing stub package-ios target in else clause for non-Darwin hosts")
	}

	// Verify proper nesting: else comes after real target, before endif
	darwinIdx := strings.Index(content, "ifeq ($(HOST_OS),Darwin)")
	elseIdx := strings.Index(content, "\nelse\n")
	if darwinIdx < 0 || elseIdx < 0 {
		t.Fatal("missing expected conditional structure")
	}
	if darwinIdx >= elseIdx {
		t.Error("else clause should come after Darwin conditional")
	}
}

func TestMakefileAggregateTargets(t *testing.T) {
	var b strings.Builder
	MakefileAggregateTargets(&b)
	content := b.String()

	if !strings.Contains(content, "packages: $(PACKAGE_TARGETS)") {
		t.Error("missing packages target")
	}
	if !strings.Contains(content, "build: packages") {
		t.Error("missing build alias")
	}
}
