package gen

import (
	"strings"
	"testing"
)

func TestComputeWASMExports_Minimal(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	exports := ComputeWASMExports(ctx.API.API.Name, ctx.API)

	if !strings.HasPrefix(exports, "[") || !strings.HasSuffix(exports, "]") {
		t.Errorf("expected JSON array, got %q", exports)
	}

	expected := []string{
		`"_malloc"`,
		`"_free"`,
		`"_test_api_lifecycle_create_engine"`,
		`"_test_api_lifecycle_destroy_engine"`,
	}
	for _, e := range expected {
		if !strings.Contains(exports, e) {
			t.Errorf("missing export %s in %s", e, exports)
		}
	}
}

func TestComputeWASMExports_Full(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	exports := ComputeWASMExports(ctx.API.API.Name, ctx.API)

	expected := []string{
		`"_malloc"`,
		`"_free"`,
		`"_example_app_engine_lifecycle_create_engine"`,
		`"_example_app_engine_renderer_create_renderer"`,
		`"_example_app_engine_texture_load_texture_from_path"`,
	}
	for _, e := range expected {
		if !strings.Contains(exports, e) {
			t.Errorf("missing export %s", e)
		}
	}
}

func TestAPIDefRelPath(t *testing.T) {
	ctx := &Context{
		OutputDir:  "/home/user/project/generated",
		APIDefPath: "/home/user/project/api.yaml",
	}
	rel := APIDefRelPath(ctx)
	if rel != "../api.yaml" {
		t.Errorf("expected ../api.yaml, got %q", rel)
	}
}

func TestMakefileHeader(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	var b strings.Builder
	MakefileHeader(&b, ctx, "cpp")
	content := b.String()

	if !strings.Contains(content, "API_NAME  := test_api") {
		t.Error("missing API_NAME variable")
	}
	if !strings.Contains(content, "LIB_NAME  := libtest_api") {
		t.Error("missing LIB_NAME variable")
	}
	if !strings.Contains(content, "PASCAL_NAME := TestApi") {
		t.Error("missing PASCAL_NAME variable")
	}
	if !strings.Contains(content, "IMPL_LANG := cpp") {
		t.Error("missing IMPL_LANG variable")
	}
	if !strings.Contains(content, "Auto-generated by xplatter") {
		t.Error("missing auto-generated banner")
	}
}

func TestMakefileTargetConfig(t *testing.T) {
	var b strings.Builder
	MakefileTargetConfig(&b)
	content := b.String()

	if !strings.Contains(content, "TARGETS ?= ios android web desktop") {
		t.Error("missing TARGETS variable")
	}
	if !strings.Contains(content, "target_enabled") {
		t.Error("missing target_enabled function")
	}
	if !strings.Contains(content, "NDK_VERSION") {
		t.Error("missing NDK configuration")
	}
	if !strings.Contains(content, "IOS_MIN") {
		t.Error("missing iOS configuration")
	}
	if !strings.Contains(content, "EMCC") {
		t.Error("missing Emscripten configuration")
	}
}

func TestMakefileBindingVars(t *testing.T) {
	var b strings.Builder
	MakefileBindingVars(&b, "test_api", "generated/")
	content := b.String()

	if !strings.Contains(content, "GEN_HEADER         := generated/$(API_NAME).h") {
		t.Error("missing GEN_HEADER with prefix")
	}
	if !strings.Contains(content, "GEN_SWIFT_BINDING  := generated/TestApi.swift") {
		t.Error("missing GEN_SWIFT_BINDING with prefix")
	}

	// Test without prefix
	var b2 strings.Builder
	MakefileBindingVars(&b2, "test_api", "")
	content2 := b2.String()
	if !strings.Contains(content2, "GEN_HEADER         := $(API_NAME).h") {
		t.Error("missing GEN_HEADER without prefix")
	}
}

func TestMakefileCodegenStamp(t *testing.T) {
	var b strings.Builder
	MakefileCodegenStamp(&b, "rust", "-o .")
	content := b.String()

	if !strings.Contains(content, "$(XPLATTER) generate --impl-lang rust -o .") {
		t.Error("missing codegen stamp rule with correct impl-lang and output flag")
	}
	if !strings.Contains(content, "$(STAMP): $(API_DEF)") {
		t.Error("missing STAMP dependency on API_DEF")
	}
}

func TestMakefileAggregateTargets(t *testing.T) {
	var b strings.Builder
	MakefileAggregateTargets(&b)
	content := b.String()

	if !strings.Contains(content, "packages: $(PACKAGE_TARGETS)") {
		t.Error("missing packages target")
	}
	if !strings.Contains(content, "build: packages") {
		t.Error("missing build alias")
	}
}
