package gen

import (
	"fmt"
	"strings"

	"github.com/benn-herrera/xplattergy/model"
)

func init() {
	Register("jswasm", func() Generator { return &JSWASMGenerator{} })
}

// JSWASMGenerator produces a JavaScript ES module that loads and wraps a WASM build
// of the C API. It provides idiomatic JS classes for handles, string/buffer marshalling
// via WASM linear memory, and error handling that throws on non-zero return codes.
type JSWASMGenerator struct{}

func (g *JSWASMGenerator) Name() string { return "jswasm" }

func (g *JSWASMGenerator) Generate(ctx *Context) ([]*OutputFile, error) {
	api := ctx.API
	apiName := api.API.Name

	var b strings.Builder

	writeModuleHeader(&b, api)
	writeMemoryHelpers(&b)
	writeStringMarshalling(&b)
	writeBufferMarshalling(&b)
	writeHandleClasses(&b, api)
	writePlatformServiceImports(&b, apiName)
	writeWASMLoader(&b, apiName, api)
	writeInterfaceWrappers(&b, apiName, api)
	writeModuleExports(&b, apiName, api)

	filename := apiName + ".js"
	return []*OutputFile{
		{Path: filename, Content: []byte(b.String())},
	}, nil
}

// writeModuleHeader writes the top-of-file comment and shared state.
func writeModuleHeader(b *strings.Builder, api *model.APIDefinition) {
	fmt.Fprintf(b, "// %s v%s — JavaScript/WASM binding\n", api.API.Name, api.API.Version)
	fmt.Fprintf(b, "// Generated by xplattergy. Do not edit.\n\n")

	b.WriteString("const _encoder = new TextEncoder();\n")
	b.WriteString("const _decoder = new TextDecoder();\n\n")
	b.WriteString("let _wasm = null;\n\n")
}

// writeMemoryHelpers writes malloc/free wrappers for WASM linear memory.
func writeMemoryHelpers(b *strings.Builder) {
	b.WriteString("// Memory management helpers\n")
	b.WriteString("function _malloc(size) {\n")
	b.WriteString("  return _wasm.exports.malloc(size);\n")
	b.WriteString("}\n\n")

	b.WriteString("function _free(ptr) {\n")
	b.WriteString("  _wasm.exports.free(ptr);\n")
	b.WriteString("}\n\n")

	b.WriteString("function _memoryBuffer() {\n")
	b.WriteString("  return _wasm.exports.memory.buffer;\n")
	b.WriteString("}\n\n")
}

// writeStringMarshalling writes string encode/decode helpers.
func writeStringMarshalling(b *strings.Builder) {
	b.WriteString("// String marshalling\n")

	// Encode a JS string into WASM memory, returns [ptr, len] (null-terminated).
	b.WriteString("function _encodeString(str) {\n")
	b.WriteString("  const bytes = _encoder.encode(str);\n")
	b.WriteString("  const ptr = _malloc(bytes.length + 1);\n")
	b.WriteString("  const dest = new Uint8Array(_memoryBuffer(), ptr, bytes.length + 1);\n")
	b.WriteString("  dest.set(bytes);\n")
	b.WriteString("  dest[bytes.length] = 0;\n")
	b.WriteString("  return ptr;\n")
	b.WriteString("}\n\n")

	// Decode a null-terminated C string from WASM memory.
	b.WriteString("function _decodeString(ptr) {\n")
	b.WriteString("  const mem = new Uint8Array(_memoryBuffer());\n")
	b.WriteString("  let end = ptr;\n")
	b.WriteString("  while (mem[end] !== 0) end++;\n")
	b.WriteString("  return _decoder.decode(mem.subarray(ptr, end));\n")
	b.WriteString("}\n\n")
}

// writeBufferMarshalling writes TypedArray → WASM linear memory helpers.
func writeBufferMarshalling(b *strings.Builder) {
	b.WriteString("// Buffer marshalling\n")

	// Copy a TypedArray into WASM memory, returns [ptr, length].
	b.WriteString("function _copyBufferToWasm(typedArray) {\n")
	b.WriteString("  const bytes = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n")
	b.WriteString("  const ptr = _malloc(bytes.length);\n")
	b.WriteString("  const dest = new Uint8Array(_memoryBuffer(), ptr, bytes.length);\n")
	b.WriteString("  dest.set(bytes);\n")
	b.WriteString("  return [ptr, typedArray.length];\n")
	b.WriteString("}\n\n")

	// Read WASM memory back into a TypedArray (for ref_mut out-buffers).
	b.WriteString("function _readBufferFromWasm(ptr, length, TypedArrayCtor) {\n")
	b.WriteString("  const byteSize = length * TypedArrayCtor.BYTES_PER_ELEMENT;\n")
	b.WriteString("  const src = new Uint8Array(_memoryBuffer(), ptr, byteSize);\n")
	b.WriteString("  const result = new TypedArrayCtor(length);\n")
	b.WriteString("  new Uint8Array(result.buffer).set(src);\n")
	b.WriteString("  return result;\n")
	b.WriteString("}\n\n")
}

// writeHandleClasses writes wrapper classes for each handle type.
func writeHandleClasses(b *strings.Builder, api *model.APIDefinition) {
	if len(api.Handles) == 0 {
		return
	}

	b.WriteString("// Handle wrapper classes\n")
	for _, h := range api.Handles {
		className := h.Name // Already PascalCase
		fmt.Fprintf(b, "class %s {\n", className)
		fmt.Fprintf(b, "  #ptr;\n\n")

		// Constructor (internal — takes raw pointer)
		fmt.Fprintf(b, "  /** @internal */\n")
		fmt.Fprintf(b, "  constructor(ptr) {\n")
		fmt.Fprintf(b, "    this.#ptr = ptr;\n")
		fmt.Fprintf(b, "  }\n\n")

		// Raw pointer accessor for internal use
		fmt.Fprintf(b, "  /** @internal */\n")
		fmt.Fprintf(b, "  get _ptr() {\n")
		fmt.Fprintf(b, "    if (this.#ptr === 0) {\n")
		fmt.Fprintf(b, "      throw new Error('%s has been disposed');\n", className)
		fmt.Fprintf(b, "    }\n")
		fmt.Fprintf(b, "    return this.#ptr;\n")
		fmt.Fprintf(b, "  }\n\n")

		// dispose / close
		fmt.Fprintf(b, "  dispose() {\n")
		fmt.Fprintf(b, "    this.#ptr = 0;\n")
		fmt.Fprintf(b, "  }\n\n")

		fmt.Fprintf(b, "  close() {\n")
		fmt.Fprintf(b, "    this.dispose();\n")
		fmt.Fprintf(b, "  }\n\n")

		// Symbol.dispose for using declarations
		fmt.Fprintf(b, "  [Symbol.dispose]() {\n")
		fmt.Fprintf(b, "    this.dispose();\n")
		fmt.Fprintf(b, "  }\n")

		fmt.Fprintf(b, "}\n\n")
	}
}

// writePlatformServiceImports writes the env object builder for WASM imports
// that provide platform services (logging, resources).
func writePlatformServiceImports(b *strings.Builder, apiName string) {
	b.WriteString("// Platform service WASM imports\n")
	b.WriteString("function _buildPlatformImports(services) {\n")
	b.WriteString("  services = services || {};\n")
	b.WriteString("  return {\n")
	b.WriteString("    env: {\n")

	// log_sink
	fmt.Fprintf(b, "      %s_log_sink: (level, tagPtr, msgPtr) => {\n", apiName)
	b.WriteString("        if (services.logSink) {\n")
	b.WriteString("          services.logSink(level, _decodeString(tagPtr), _decodeString(msgPtr));\n")
	b.WriteString("        }\n")
	b.WriteString("      },\n")

	// resource_count
	fmt.Fprintf(b, "      %s_resource_count: () => {\n", apiName)
	b.WriteString("        return services.resourceCount ? services.resourceCount() : 0;\n")
	b.WriteString("      },\n")

	// resource_name
	fmt.Fprintf(b, "      %s_resource_name: (index, bufferPtr, bufferSize) => {\n", apiName)
	b.WriteString("        if (!services.resourceName) return -1;\n")
	b.WriteString("        const name = services.resourceName(index);\n")
	b.WriteString("        if (!name) return -1;\n")
	b.WriteString("        const bytes = _encoder.encode(name);\n")
	b.WriteString("        if (bytes.length + 1 > bufferSize) return -1;\n")
	b.WriteString("        const dest = new Uint8Array(_memoryBuffer(), bufferPtr, bufferSize);\n")
	b.WriteString("        dest.set(bytes);\n")
	b.WriteString("        dest[bytes.length] = 0;\n")
	b.WriteString("        return bytes.length;\n")
	b.WriteString("      },\n")

	// resource_exists
	fmt.Fprintf(b, "      %s_resource_exists: (namePtr) => {\n", apiName)
	b.WriteString("        if (!services.resourceExists) return 0;\n")
	b.WriteString("        return services.resourceExists(_decodeString(namePtr)) ? 1 : 0;\n")
	b.WriteString("      },\n")

	// resource_size
	fmt.Fprintf(b, "      %s_resource_size: (namePtr) => {\n", apiName)
	b.WriteString("        if (!services.resourceSize) return 0;\n")
	b.WriteString("        return services.resourceSize(_decodeString(namePtr));\n")
	b.WriteString("      },\n")

	// resource_read
	fmt.Fprintf(b, "      %s_resource_read: (namePtr, bufferPtr, bufferSize) => {\n", apiName)
	b.WriteString("        if (!services.resourceRead) return -1;\n")
	b.WriteString("        const data = services.resourceRead(_decodeString(namePtr));\n")
	b.WriteString("        if (!data || data.length > bufferSize) return -1;\n")
	b.WriteString("        const dest = new Uint8Array(_memoryBuffer(), bufferPtr, bufferSize);\n")
	b.WriteString("        dest.set(new Uint8Array(data.buffer || data));\n")
	b.WriteString("        return data.length;\n")
	b.WriteString("      },\n")

	b.WriteString("    },\n")
	b.WriteString("  };\n")
	b.WriteString("}\n\n")
}

// writeWASMLoader writes the async loader function that instantiates the WASM module.
func writeWASMLoader(b *strings.Builder, apiName string, api *model.APIDefinition) {
	loaderName := ToCamelCase("load_" + apiName)
	fmt.Fprintf(b, "// WASM module loader\n")
	fmt.Fprintf(b, "export async function %s(wasmSource, platformServices) {\n", loaderName)
	b.WriteString("  const imports = _buildPlatformImports(platformServices);\n")
	b.WriteString("  let result;\n")
	b.WriteString("  if (wasmSource instanceof WebAssembly.Module) {\n")
	b.WriteString("    result = await WebAssembly.instantiate(wasmSource, imports);\n")
	b.WriteString("    _wasm = { exports: result.exports };\n")
	b.WriteString("  } else if (wasmSource instanceof Response || typeof wasmSource === 'string') {\n")
	b.WriteString("    const response = typeof wasmSource === 'string' ? fetch(wasmSource) : wasmSource;\n")
	b.WriteString("    result = await WebAssembly.instantiateStreaming(response, imports);\n")
	b.WriteString("    _wasm = result.instance;\n")
	b.WriteString("  } else if (wasmSource instanceof ArrayBuffer || ArrayBuffer.isView(wasmSource)) {\n")
	b.WriteString("    const module = await WebAssembly.compile(wasmSource);\n")
	b.WriteString("    result = await WebAssembly.instantiate(module, imports);\n")
	b.WriteString("    _wasm = { exports: result.exports };\n")
	b.WriteString("  } else {\n")
	b.WriteString("    throw new Error('wasmSource must be a URL string, Response, WebAssembly.Module, or ArrayBuffer');\n")
	b.WriteString("  }\n")
	b.WriteString("  return {\n")

	// Return an object with all interface namespaces
	for _, iface := range api.Interfaces {
		jsName := ToCamelCase(iface.Name)
		fmt.Fprintf(b, "    %s: _create%s(),\n", jsName, ToPascalCase(iface.Name))
	}

	b.WriteString("  };\n")
	b.WriteString("}\n\n")
}

// writeInterfaceWrappers writes a factory function for each interface that returns
// an object with all methods properly wrapped.
func writeInterfaceWrappers(b *strings.Builder, apiName string, api *model.APIDefinition) {
	for _, iface := range api.Interfaces {
		factoryName := "_create" + ToPascalCase(iface.Name)
		fmt.Fprintf(b, "// %s interface\n", iface.Name)
		fmt.Fprintf(b, "function %s() {\n", factoryName)
		b.WriteString("  return {\n")

		for i, method := range iface.Methods {
			writeMethodWrapper(b, apiName, iface.Name, &method)
			if i < len(iface.Methods)-1 {
				b.WriteString("\n")
			}
		}

		b.WriteString("  };\n")
		b.WriteString("}\n\n")
	}
}

// writeMethodWrapper writes a single method wrapper inside an interface object.
func writeMethodWrapper(b *strings.Builder, apiName, ifaceName string, method *model.MethodDef) {
	funcName := CABIFunctionName(apiName, ifaceName, method.Name)
	jsMethodName := ToCamelCase(method.Name)
	hasError := method.Error != ""
	hasReturn := method.Returns != nil

	// Build JS parameter list
	var jsParams []string
	for _, p := range method.Parameters {
		jsParams = append(jsParams, ToCamelCase(p.Name))
	}

	paramStr := strings.Join(jsParams, ", ")
	fmt.Fprintf(b, "    %s(%s) {\n", jsMethodName, paramStr)

	// Marshalling prologue — allocate temporaries we'll need to free.
	// Track allocated pointers for cleanup.
	var marshalledParams []marshalledParam
	var cleanupPtrs []string

	for _, p := range method.Parameters {
		mp := marshalParam(p)
		marshalledParams = append(marshalledParams, mp)
		if mp.needsMarshal {
			for _, line := range mp.marshalLines {
				fmt.Fprintf(b, "      %s\n", line)
			}
			cleanupPtrs = append(cleanupPtrs, mp.cleanupPtrs...)
		}
	}

	// For fallible + return, allocate out-parameter space
	if hasError && hasReturn {
		outSize := wasmOutParamSize(method.Returns.Type)
		fmt.Fprintf(b, "      const _outPtr = _malloc(%d);\n", outSize)
		cleanupPtrs = append(cleanupPtrs, "_outPtr")
	}

	// Build WASM call arguments
	var wasmArgs []string
	for _, mp := range marshalledParams {
		wasmArgs = append(wasmArgs, mp.wasmArgs...)
	}
	if hasError && hasReturn {
		wasmArgs = append(wasmArgs, "_outPtr")
	}

	wasmArgStr := strings.Join(wasmArgs, ", ")

	// Wrap in try/finally if we need cleanup
	needsCleanup := len(cleanupPtrs) > 0
	if needsCleanup {
		b.WriteString("      try {\n")
	}

	indent := "      "
	if needsCleanup {
		indent = "        "
	}

	// The actual WASM call
	switch {
	case hasError && hasReturn:
		fmt.Fprintf(b, "%sconst _rc = _wasm.exports.%s(%s);\n", indent, funcName, wasmArgStr)
		fmt.Fprintf(b, "%sif (_rc !== 0) {\n", indent)
		fmt.Fprintf(b, "%s  throw new Error(`%s failed with error code ${_rc}`);\n", indent, jsMethodName)
		fmt.Fprintf(b, "%s}\n", indent)
		writeReturnRead(b, indent, method.Returns.Type)

	case hasError && !hasReturn:
		fmt.Fprintf(b, "%sconst _rc = _wasm.exports.%s(%s);\n", indent, funcName, wasmArgStr)
		fmt.Fprintf(b, "%sif (_rc !== 0) {\n", indent)
		fmt.Fprintf(b, "%s  throw new Error(`%s failed with error code ${_rc}`);\n", indent, jsMethodName)
		fmt.Fprintf(b, "%s}\n", indent)

	case !hasError && hasReturn:
		fmt.Fprintf(b, "%sconst _result = _wasm.exports.%s(%s);\n", indent, funcName, wasmArgStr)
		writeDirectReturn(b, indent, method.Returns.Type)

	default:
		fmt.Fprintf(b, "%s_wasm.exports.%s(%s);\n", indent, funcName, wasmArgStr)
	}

	if needsCleanup {
		b.WriteString("      } finally {\n")
		for _, ptr := range cleanupPtrs {
			fmt.Fprintf(b, "        _free(%s);\n", ptr)
		}
		b.WriteString("      }\n")
	}

	b.WriteString("    },\n")
}

// marshalledParam tracks how a parameter is marshalled from JS to WASM.
type marshalledParam struct {
	needsMarshal bool
	marshalLines []string // Lines to emit in the prologue
	wasmArgs     []string // Argument expressions for the WASM call
	cleanupPtrs  []string // Pointers that need _free in finally block
}

// marshalParam determines how to pass a JS parameter to WASM.
func marshalParam(p model.ParameterDef) marshalledParam {
	jsName := ToCamelCase(p.Name)

	if model.IsString(p.Type) {
		ptrVar := "_" + jsName + "Ptr"
		return marshalledParam{
			needsMarshal: true,
			marshalLines: []string{
				fmt.Sprintf("const %s = _encodeString(%s);", ptrVar, jsName),
			},
			wasmArgs:    []string{ptrVar},
			cleanupPtrs: []string{ptrVar},
		}
	}

	if _, ok := model.IsBuffer(p.Type); ok {
		ptrVar := "_" + jsName + "Ptr"
		lenVar := "_" + jsName + "Len"
		return marshalledParam{
			needsMarshal: true,
			marshalLines: []string{
				fmt.Sprintf("const [%s, %s] = _copyBufferToWasm(%s);", ptrVar, lenVar, jsName),
			},
			wasmArgs:    []string{ptrVar, lenVar},
			cleanupPtrs: []string{ptrVar},
		}
	}

	if _, ok := model.IsHandle(p.Type); ok {
		return marshalledParam{
			wasmArgs: []string{jsName + "._ptr"},
		}
	}

	// Primitives and FlatBuffer types pass through directly
	return marshalledParam{
		wasmArgs: []string{jsName},
	}
}

// writeReturnRead writes code to read the out-parameter result after a successful fallible call.
func writeReturnRead(b *strings.Builder, indent string, retType string) {
	if handleName, ok := model.IsHandle(retType); ok {
		fmt.Fprintf(b, "%sconst _view = new DataView(_memoryBuffer());\n", indent)
		fmt.Fprintf(b, "%sconst _handleVal = _view.getUint32(_outPtr, true);\n", indent)
		fmt.Fprintf(b, "%sreturn new %s(_handleVal);\n", indent, handleName)
		return
	}

	if model.IsPrimitive(retType) {
		getter := wasmDataViewGetter(retType)
		fmt.Fprintf(b, "%sconst _view = new DataView(_memoryBuffer());\n", indent)
		fmt.Fprintf(b, "%sreturn _view.%s(_outPtr, true);\n", indent, getter)
		return
	}

	// FlatBuffer types: return the raw bytes (caller decodes)
	fmt.Fprintf(b, "%sconst _view = new DataView(_memoryBuffer());\n", indent)
	fmt.Fprintf(b, "%sreturn _view.getUint32(_outPtr, true);\n", indent)
}

// writeDirectReturn writes code to return a direct (non-out-param) return value.
func writeDirectReturn(b *strings.Builder, indent string, retType string) {
	if handleName, ok := model.IsHandle(retType); ok {
		fmt.Fprintf(b, "%sreturn new %s(_result);\n", indent, handleName)
		return
	}

	// Primitives return directly from WASM — no wrapping needed.
	fmt.Fprintf(b, "%sreturn _result;\n", indent)
}

// writeModuleExports writes the default export and named exports.
func writeModuleExports(b *strings.Builder, apiName string, api *model.APIDefinition) {
	loaderName := ToCamelCase("load_" + apiName)

	// Export handle classes
	b.WriteString("// Exports\n")
	fmt.Fprintf(b, "export { %s };\n", loaderName)
	for _, h := range api.Handles {
		fmt.Fprintf(b, "export { %s };\n", h.Name)
	}
}

// wasmOutParamSize returns the byte size needed for an out-parameter of the given type.
func wasmOutParamSize(retType string) int {
	if _, ok := model.IsHandle(retType); ok {
		return 4 // handle is a 32-bit pointer
	}
	switch retType {
	case "int8", "uint8", "bool":
		return 1
	case "int16", "uint16":
		return 2
	case "int32", "uint32", "float32":
		return 4
	case "int64", "uint64", "float64":
		return 8
	default:
		return 4 // FlatBuffer types — pointer-sized
	}
}

// wasmDataViewGetter returns the DataView getter method for a primitive type.
func wasmDataViewGetter(t string) string {
	switch t {
	case "int8":
		return "getInt8"
	case "uint8":
		return "getUint8"
	case "int16":
		return "getInt16"
	case "uint16":
		return "getUint16"
	case "int32":
		return "getInt32"
	case "uint32":
		return "getUint32"
	case "float32":
		return "getFloat32"
	case "float64":
		return "getFloat64"
	case "bool":
		return "getUint8"
	default:
		return "getUint32"
	}
}
