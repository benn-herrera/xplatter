package gen

import (
	"strings"
	"testing"
)

func TestRustImplGenerator_Minimal(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	if len(files) != 6 {
		t.Fatalf("expected 6 output files, got %d", len(files))
	}

	// Verify filenames: non-scaffold .rs files have no prefix (go into generated/),
	// scaffold files keep src/ prefix and use ProjectFile (go into project root).
	expectedNames := []string{
		"test_api_trait.rs",
		"test_api_ffi.rs",
		"src/test_api_impl.rs",
		"test_api_types.rs",
		"Cargo.toml",
		"src/lib.rs",
	}
	for i, name := range expectedNames {
		if files[i].Path != name {
			t.Errorf("expected file[%d] = %q, got %q", i, name, files[i].Path)
		}
	}

	// Verify scaffold and ProjectFile flags
	type fileExpect struct {
		scaffold    bool
		projectFile bool
	}
	expectedFlags := map[string]fileExpect{
		"test_api_trait.rs":    {false, false},
		"test_api_ffi.rs":     {false, false},
		"src/test_api_impl.rs": {true, true},
		"test_api_types.rs":   {false, false},
		"Cargo.toml":          {true, true},
		"src/lib.rs":          {true, true},
	}
	for _, f := range files {
		expect := expectedFlags[f.Path]
		if expect.scaffold && !f.Scaffold {
			t.Errorf("%s should be scaffold", f.Path)
		}
		if !expect.scaffold && f.Scaffold {
			t.Errorf("%s should not be scaffold", f.Path)
		}
		if expect.projectFile && !f.ProjectFile {
			t.Errorf("%s should be ProjectFile", f.Path)
		}
		if !expect.projectFile && f.ProjectFile {
			t.Errorf("%s should not be ProjectFile", f.Path)
		}
	}
}

func TestRustImplGenerator_TraitDefinition(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)

	// Trait declaration
	if !strings.Contains(trait, "pub trait Lifecycle {") {
		t.Error("missing trait declaration for Lifecycle")
	}

	// Fallible method with handle return: Result<*mut c_void, ErrorCode>
	if !strings.Contains(trait, "fn create_engine") {
		t.Error("missing create_engine method in trait")
	}
	if !strings.Contains(trait, "Result<*mut c_void, CommonErrorCode>") {
		t.Error("missing Result<*mut c_void, CommonErrorCode> return type")
	}

	// Infallible void method with handle param
	if !strings.Contains(trait, "fn destroy_engine") {
		t.Error("missing destroy_engine method in trait")
	}
	if !strings.Contains(trait, "engine: *mut c_void") {
		t.Error("missing handle parameter type *mut c_void")
	}

	// Auto-gen comment
	if !strings.Contains(trait, "Generated by xplatter") {
		t.Error("missing generated file header")
	}

	// Types import when resolved types present
	if !strings.Contains(trait, "use crate::test_api_types::*;") {
		t.Error("missing use crate::test_api_types::* import in trait file")
	}
}

func TestRustImplGenerator_FFIShim(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	ffi := string(files[1].Content)

	// #[no_mangle] attribute
	if !strings.Contains(ffi, "#[no_mangle]") {
		t.Error("missing #[no_mangle] attribute")
	}

	// extern "C" function
	if !strings.Contains(ffi, "pub unsafe extern \"C\" fn") {
		t.Error("missing extern \"C\" function declaration")
	}

	// C ABI function name
	if !strings.Contains(ffi, "test_api_lifecycle_create_engine") {
		t.Error("missing create_engine FFI function name")
	}
	if !strings.Contains(ffi, "test_api_lifecycle_destroy_engine") {
		t.Error("missing destroy_engine FFI function name")
	}

	// Fallible with return: out_result parameter
	if !strings.Contains(ffi, "out_result: *mut *mut c_void") {
		t.Error("missing out_result parameter for fallible+return method")
	}

	// Result match pattern
	if !strings.Contains(ffi, "match") {
		t.Error("missing match expression in FFI shim")
	}
	if !strings.Contains(ffi, "Ok(val)") {
		t.Error("missing Ok(val) arm in FFI match")
	}
	if !strings.Contains(ffi, "Err(e)") {
		t.Error("missing Err(e) arm in FFI match")
	}
	if !strings.Contains(ffi, "*out_result = val") {
		t.Error("missing out_result write in Ok arm")
	}
}

func TestRustImplGenerator_StubImpl(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	impl := string(files[2].Content)

	// Struct declaration
	if !strings.Contains(impl, "pub struct Impl;") {
		t.Error("missing Impl struct declaration")
	}

	// Trait impl block
	if !strings.Contains(impl, "impl Lifecycle for Impl {") {
		t.Error("missing impl Lifecycle for Impl block")
	}

	// todo!() macro in method bodies
	if !strings.Contains(impl, "todo!()") {
		t.Error("missing todo!() macro in stub methods")
	}

	// TODO comment
	if !strings.Contains(impl, "// TODO: implement create_engine") {
		t.Error("missing TODO comment for create_engine")
	}
	if !strings.Contains(impl, "// TODO: implement destroy_engine") {
		t.Error("missing TODO comment for destroy_engine")
	}
}

func TestRustImplGenerator_CargoToml(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	// Cargo.toml is file[4]
	cargo := string(files[4].Content)

	if !strings.Contains(cargo, `name = "test_api"`) {
		t.Error("missing package name in Cargo.toml")
	}
	if !strings.Contains(cargo, `version = "0.1.0"`) {
		t.Error("missing version in Cargo.toml")
	}
	if !strings.Contains(cargo, `edition = "2021"`) {
		t.Error("missing edition in Cargo.toml")
	}
	if !strings.Contains(cargo, `crate-type = ["cdylib", "staticlib", "rlib"]`) {
		t.Error("missing crate-type in Cargo.toml")
	}
}

func TestRustImplGenerator_LibRs(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	// lib.rs is file[5]
	librs := string(files[5].Content)

	if !strings.Contains(librs, "pub mod test_api_types;") {
		t.Error("missing types module in lib.rs")
	}
	if !strings.Contains(librs, "pub mod test_api_trait;") {
		t.Error("missing trait module in lib.rs")
	}
	if !strings.Contains(librs, "pub mod test_api_ffi;") {
		t.Error("missing ffi module in lib.rs")
	}
	if !strings.Contains(librs, "pub mod test_api_impl;") {
		t.Error("missing impl module in lib.rs")
	}

	// Generated modules use #[path] to reference files in ../generated/
	if !strings.Contains(librs, `#[path = "../generated/test_api_types.rs"]`) {
		t.Error("missing #[path] for types module")
	}
	if !strings.Contains(librs, `#[path = "../generated/test_api_trait.rs"]`) {
		t.Error("missing #[path] for trait module")
	}
	if !strings.Contains(librs, `#[path = "../generated/test_api_ffi.rs"]`) {
		t.Error("missing #[path] for ffi module")
	}
	// impl module should NOT have #[path] â€” it's in src/ alongside lib.rs
	if strings.Contains(librs, `#[path = "../generated/test_api_impl.rs"]`) {
		t.Error("impl module should not have #[path] attribute")
	}
}

func TestRustImplGenerator_FullAPI(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	if len(files) != 6 {
		t.Fatalf("expected 6 output files, got %d", len(files))
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// String parameter
	if !strings.Contains(trait, "path: &str") {
		t.Error("missing &str parameter in trait for string type")
	}
	if !strings.Contains(ffi, "path: *const c_char") {
		t.Error("missing *const c_char in FFI for string type")
	}
	if !strings.Contains(ffi, "CStr::from_ptr(path)") {
		t.Error("missing CStr::from_ptr conversion for string param")
	}

	// Buffer parameter
	if !strings.Contains(trait, "data: &[u8]") {
		t.Error("missing &[u8] parameter in trait for buffer<uint8>")
	}
	if !strings.Contains(ffi, "data_len: u32") {
		t.Error("missing data_len parameter in FFI for buffer")
	}
	if !strings.Contains(ffi, "std::slice::from_raw_parts(data") {
		t.Error("missing std::slice::from_raw_parts in FFI for buffer")
	}

	// Multiple traits
	expectedTraits := []string{
		"pub trait Lifecycle {",
		"pub trait Renderer {",
		"pub trait Texture {",
		"pub trait Input {",
		"pub trait Events {",
	}
	for _, expected := range expectedTraits {
		if !strings.Contains(trait, expected) {
			t.Errorf("missing trait declaration: %s", expected)
		}
	}

	// Multiple FFI functions
	expectedFuncs := []string{
		"example_app_engine_lifecycle_create_engine",
		"example_app_engine_renderer_create_renderer",
		"example_app_engine_texture_load_texture_from_path",
		"example_app_engine_texture_load_texture_from_buffer",
		"example_app_engine_input_push_touch_events",
		"example_app_engine_events_poll_events",
	}
	for _, fn := range expectedFuncs {
		if !strings.Contains(ffi, fn) {
			t.Errorf("missing FFI function: %s", fn)
		}
	}
}

func TestRustImplGenerator_FallibleWithoutReturn(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// begin_frame is fallible without return: Result<(), ErrorCode>
	if !strings.Contains(trait, "Result<(), CommonErrorCode>") {
		t.Error("missing Result<(), CommonErrorCode> for fallible void method")
	}

	// FFI should return i32 and match on Ok(())
	if !strings.Contains(ffi, "Ok(()) => 0") {
		t.Error("missing Ok(()) => 0 pattern for fallible void method")
	}
}

func TestRustImplGenerator_MutableRefParam(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// poll_events has ref_mut FlatBuffer parameter (Common.EventQueue)
	if !strings.Contains(trait, "events: &mut CommonEventQueue") {
		t.Error("missing &mut CommonEventQueue trait parameter for ref_mut FlatBuffer")
	}

	// FFI should accept *mut pointer and dereference to &mut
	if !strings.Contains(ffi, "events: *mut CommonEventQueue") {
		t.Error("missing *mut CommonEventQueue FFI parameter for ref_mut FlatBuffer")
	}
	if !strings.Contains(ffi, "let events = &mut *events") {
		t.Error("missing &mut * dereference for ref_mut FlatBuffer parameter")
	}
}

func TestRustImplGenerator_Registry(t *testing.T) {
	gen, ok := Get("impl_rust")
	if !ok {
		t.Fatal("impl_rust generator not found in registry")
	}
	if gen.Name() != "impl_rust" {
		t.Errorf("expected name %q, got %q", "impl_rust", gen.Name())
	}
}
