package gen

import (
	"strings"
	"testing"
)

func TestRustImplGenerator_Minimal(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	if len(files) != 4 {
		t.Fatalf("expected 4 output files, got %d", len(files))
	}

	// Verify filenames
	expectedNames := []string{
		"test_api_trait.rs",
		"test_api_ffi.rs",
		"test_api_impl.rs",
		"test_api_types.rs",
	}
	for i, name := range expectedNames {
		if files[i].Path != name {
			t.Errorf("expected file[%d] = %q, got %q", i, name, files[i].Path)
		}
	}
}

func TestRustImplGenerator_TraitDefinition(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)

	// Trait declaration
	if !strings.Contains(trait, "pub trait Lifecycle {") {
		t.Error("missing trait declaration for Lifecycle")
	}

	// Fallible method with handle return: Result<*mut c_void, ErrorCode>
	if !strings.Contains(trait, "fn create_engine") {
		t.Error("missing create_engine method in trait")
	}
	if !strings.Contains(trait, "Result<*mut c_void, CommonErrorCode>") {
		t.Error("missing Result<*mut c_void, CommonErrorCode> return type")
	}

	// Infallible void method with handle param
	if !strings.Contains(trait, "fn destroy_engine") {
		t.Error("missing destroy_engine method in trait")
	}
	if !strings.Contains(trait, "engine: *mut c_void") {
		t.Error("missing handle parameter type *mut c_void")
	}

	// Auto-gen comment
	if !strings.Contains(trait, "Auto-generated by xplatter") {
		t.Error("missing auto-generated comment")
	}
}

func TestRustImplGenerator_FFIShim(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	ffi := string(files[1].Content)

	// #[no_mangle] attribute
	if !strings.Contains(ffi, "#[no_mangle]") {
		t.Error("missing #[no_mangle] attribute")
	}

	// extern "C" function
	if !strings.Contains(ffi, "pub unsafe extern \"C\" fn") {
		t.Error("missing extern \"C\" function declaration")
	}

	// C ABI function name
	if !strings.Contains(ffi, "test_api_lifecycle_create_engine") {
		t.Error("missing create_engine FFI function name")
	}
	if !strings.Contains(ffi, "test_api_lifecycle_destroy_engine") {
		t.Error("missing destroy_engine FFI function name")
	}

	// Fallible with return: out_result parameter
	if !strings.Contains(ffi, "out_result: *mut *mut c_void") {
		t.Error("missing out_result parameter for fallible+return method")
	}

	// Result match pattern
	if !strings.Contains(ffi, "match") {
		t.Error("missing match expression in FFI shim")
	}
	if !strings.Contains(ffi, "Ok(val)") {
		t.Error("missing Ok(val) arm in FFI match")
	}
	if !strings.Contains(ffi, "Err(e)") {
		t.Error("missing Err(e) arm in FFI match")
	}
	if !strings.Contains(ffi, "*out_result = val") {
		t.Error("missing out_result write in Ok arm")
	}
}

func TestRustImplGenerator_StubImpl(t *testing.T) {
	ctx := loadTestAPI(t, "minimal.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	impl := string(files[2].Content)

	// Struct declaration
	if !strings.Contains(impl, "pub struct Impl;") {
		t.Error("missing Impl struct declaration")
	}

	// Trait impl block
	if !strings.Contains(impl, "impl Lifecycle for Impl {") {
		t.Error("missing impl Lifecycle for Impl block")
	}

	// todo!() macro in method bodies
	if !strings.Contains(impl, "todo!()") {
		t.Error("missing todo!() macro in stub methods")
	}

	// TODO comment
	if !strings.Contains(impl, "// TODO: implement create_engine") {
		t.Error("missing TODO comment for create_engine")
	}
	if !strings.Contains(impl, "// TODO: implement destroy_engine") {
		t.Error("missing TODO comment for destroy_engine")
	}
}

func TestRustImplGenerator_FullAPI(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	if len(files) != 4 {
		t.Fatalf("expected 4 output files, got %d", len(files))
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// String parameter
	if !strings.Contains(trait, "path: &str") {
		t.Error("missing &str parameter in trait for string type")
	}
	if !strings.Contains(ffi, "path: *const c_char") {
		t.Error("missing *const c_char in FFI for string type")
	}
	if !strings.Contains(ffi, "CStr::from_ptr(path)") {
		t.Error("missing CStr::from_ptr conversion for string param")
	}

	// Buffer parameter
	if !strings.Contains(trait, "data: &[u8]") {
		t.Error("missing &[u8] parameter in trait for buffer<uint8>")
	}
	if !strings.Contains(ffi, "data_len: u32") {
		t.Error("missing data_len parameter in FFI for buffer")
	}
	if !strings.Contains(ffi, "std::slice::from_raw_parts(data") {
		t.Error("missing std::slice::from_raw_parts in FFI for buffer")
	}

	// Multiple traits
	expectedTraits := []string{
		"pub trait Lifecycle {",
		"pub trait Renderer {",
		"pub trait Texture {",
		"pub trait Input {",
		"pub trait Events {",
	}
	for _, expected := range expectedTraits {
		if !strings.Contains(trait, expected) {
			t.Errorf("missing trait declaration: %s", expected)
		}
	}

	// Multiple FFI functions
	expectedFuncs := []string{
		"example_app_engine_lifecycle_create_engine",
		"example_app_engine_renderer_create_renderer",
		"example_app_engine_texture_load_texture_from_path",
		"example_app_engine_texture_load_texture_from_buffer",
		"example_app_engine_input_push_touch_events",
		"example_app_engine_events_poll_events",
	}
	for _, fn := range expectedFuncs {
		if !strings.Contains(ffi, fn) {
			t.Errorf("missing FFI function: %s", fn)
		}
	}
}

func TestRustImplGenerator_FallibleWithoutReturn(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// begin_frame is fallible without return: Result<(), ErrorCode>
	if !strings.Contains(trait, "Result<(), CommonErrorCode>") {
		t.Error("missing Result<(), CommonErrorCode> for fallible void method")
	}

	// FFI should return i32 and match on Ok(())
	if !strings.Contains(ffi, "Ok(()) => 0") {
		t.Error("missing Ok(()) => 0 pattern for fallible void method")
	}
}

func TestRustImplGenerator_MutableRefParam(t *testing.T) {
	ctx := loadTestAPI(t, "full.yaml")
	gen := &RustImplGenerator{}

	files, err := gen.Generate(ctx)
	if err != nil {
		t.Fatalf("generation failed: %v", err)
	}

	trait := string(files[0].Content)
	ffi := string(files[1].Content)

	// poll_events has ref_mut FlatBuffer parameter (Common.EventQueue)
	if !strings.Contains(trait, "events: &mut CommonEventQueue") {
		t.Error("missing &mut CommonEventQueue trait parameter for ref_mut FlatBuffer")
	}

	// FFI should accept *mut pointer and dereference to &mut
	if !strings.Contains(ffi, "events: *mut CommonEventQueue") {
		t.Error("missing *mut CommonEventQueue FFI parameter for ref_mut FlatBuffer")
	}
	if !strings.Contains(ffi, "let events = &mut *events") {
		t.Error("missing &mut * dereference for ref_mut FlatBuffer parameter")
	}
}

func TestRustImplGenerator_Registry(t *testing.T) {
	gen, ok := Get("impl_rust")
	if !ok {
		t.Fatal("impl_rust generator not found in registry")
	}
	if gen.Name() != "impl_rust" {
		t.Errorf("expected name %q, got %q", "impl_rust", gen.Name())
	}
}
