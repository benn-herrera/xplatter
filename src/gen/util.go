package gen

import (
	"fmt"
	"strings"

	"github.com/benn-herrera/xplatter/model"
)

// CABIFunctionName builds the C ABI function name: <api_name>_<interface>_<method>
func CABIFunctionName(apiName, ifaceName, methodName string) string {
	return fmt.Sprintf("%s_%s_%s", apiName, ifaceName, methodName)
}

// HandleTypedefName returns the C typedef name for a handle.
// e.g., "Engine" → "engine_handle"
func HandleTypedefName(handleName string) string {
	return model.HandleToSnake(handleName) + "_handle"
}

// HandleStructName returns the C struct tag for a handle.
// e.g., "Engine" → "engine_s"
func HandleStructName(handleName string) string {
	return model.HandleToSnake(handleName) + "_s"
}

// CParamType returns the C type string for a parameter, considering transfer semantics.
func CParamType(paramType string, transfer string) string {
	if model.IsString(paramType) {
		return "const char*"
	}

	if elemType, ok := model.IsBuffer(paramType); ok {
		cType := model.PrimitiveCType(elemType)
		if transfer == "ref_mut" {
			return cType + "*"
		}
		return "const " + cType + "*"
	}

	if handleName, ok := model.IsHandle(paramType); ok {
		return HandleTypedefName(handleName)
	}

	if model.IsPrimitive(paramType) {
		return model.PrimitiveCType(paramType)
	}

	// FlatBuffer type
	cType := model.FlatBufferCType(paramType)
	if transfer == "ref_mut" {
		return cType + "*"
	}
	if transfer == "ref" {
		return "const " + cType + "*"
	}
	return cType
}

// CReturnType returns the C type string for a return value.
func CReturnType(retType string) string {
	if handleName, ok := model.IsHandle(retType); ok {
		return HandleTypedefName(handleName)
	}
	if model.IsPrimitive(retType) {
		return model.PrimitiveCType(retType)
	}
	// FlatBuffer type
	return model.FlatBufferCType(retType)
}

// COutParamType returns the C type for an out-parameter (pointer to return type).
func COutParamType(retType string) string {
	return CReturnType(retType) + "*"
}

// UpperSnakeCase converts a snake_case string to UPPER_SNAKE_CASE.
func UpperSnakeCase(s string) string {
	return strings.ToUpper(s)
}

// ToPascalCase converts a snake_case string to PascalCase.
func ToPascalCase(s string) string {
	parts := strings.Split(s, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) == 0 {
			continue
		}
		result.WriteString(strings.ToUpper(part[:1]))
		if len(part) > 1 {
			result.WriteString(part[1:])
		}
	}
	return result.String()
}

// ToCamelCase converts a snake_case string to camelCase.
func ToCamelCase(s string) string {
	pascal := ToPascalCase(s)
	if len(pascal) == 0 {
		return ""
	}
	return strings.ToLower(pascal[:1]) + pascal[1:]
}

// ExportMacroName returns the export macro name for an API, e.g. "HELLO_XPLATTER_EXPORT".
func ExportMacroName(apiName string) string {
	return UpperSnakeCase(apiName) + "_EXPORT"
}

// BuildMacroName returns the build macro name for an API, e.g. "HELLO_XPLATTER_BUILD".
func BuildMacroName(apiName string) string {
	return UpperSnakeCase(apiName) + "_BUILD"
}

// CollectErrorTypes returns deduplicated error type names used across all methods and constructors.
func CollectErrorTypes(api *model.APIDefinition) []string {
	seen := map[string]bool{}
	var result []string
	collect := func(errType string) {
		if errType != "" && !seen[errType] {
			seen[errType] = true
			result = append(result, errType)
		}
	}
	for _, iface := range api.Interfaces {
		for _, ctor := range iface.Constructors {
			collect(ctor.Error)
		}
		for _, method := range iface.Methods {
			collect(method.Error)
		}
	}
	return result
}

// generatedHeaderLines returns the two advisory lines for a generated file header.
// The first line identifies the tool, version, and timestamp. The second line
// indicates whether the file is a scaffold or will be overwritten on regeneration.
func generatedHeaderLines(ctx *Context) (genLine, adviseLine string) {
	version := ctx.Version
	if version == "" {
		version = "dev"
	}
	stamp := ctx.Timestamp.Local().Format("2006-01-02 15:04:05 MST")
	return fmt.Sprintf("Generated by xplatter %s on %s.", version, stamp),
		"DO NOT EDIT — this file is regenerated each time xplatter runs."
}

// generatedHeaderLinesScaffold is like generatedHeaderLines but returns the
// scaffold advisory instead of the do-not-edit advisory.
func generatedHeaderLinesScaffold(ctx *Context) (genLine, adviseLine string) {
	genLine, _ = generatedHeaderLines(ctx)
	return genLine, "This is a scaffold — customize as needed. Regeneration will not overwrite this file."
}

// headerLines returns the two header lines, choosing scaffold or non-scaffold advisory.
func headerLines(ctx *Context, scaffold bool) (string, string) {
	if scaffold {
		return generatedHeaderLinesScaffold(ctx)
	}
	return generatedHeaderLines(ctx)
}

// GeneratedFileHeader returns a line-comment header identifying a file as generated.
// commentPrefix is the line-comment prefix for the language (e.g. "//", "#").
func GeneratedFileHeader(ctx *Context, commentPrefix string, scaffold bool) string {
	genLine, adviseLine := headerLines(ctx, scaffold)
	var b strings.Builder
	fmt.Fprintf(&b, "%s %s\n", commentPrefix, genLine)
	fmt.Fprintf(&b, "%s %s\n", commentPrefix, adviseLine)
	return b.String()
}

// GeneratedFileHeaderBlock returns a C-style block comment (/* ... */) header
// identifying a file as generated.
func GeneratedFileHeaderBlock(ctx *Context, scaffold bool) string {
	genLine, adviseLine := headerLines(ctx, scaffold)
	var b strings.Builder
	b.WriteString("/*\n")
	fmt.Fprintf(&b, " * %s\n", genLine)
	fmt.Fprintf(&b, " * %s\n", adviseLine)
	b.WriteString(" */\n")
	return b.String()
}

// prependHeader prepends a header string (with trailing newline separator) to file content.
func prependHeader(header string, content []byte) []byte {
	return []byte(header + "\n" + string(content))
}

// DestructorMethodName returns the auto-generated destructor method name for a handle.
// e.g., handleName "Greeter" → "destroy_greeter"
func DestructorMethodName(handleName string) string {
	return "destroy_" + model.HandleToSnake(handleName)
}

// DestructorParam returns the single ParameterDef for an auto-generated destructor.
func DestructorParam(handleName string) model.ParameterDef {
	return model.ParameterDef{
		Name: model.HandleToSnake(handleName),
		Type: "handle:" + handleName,
	}
}

// InterfaceHasConstructors reports whether an interface has constructor declarations.
func InterfaceHasConstructors(iface *model.InterfaceDef) bool {
	return len(iface.Constructors) > 0
}

// SyntheticDestructor returns a synthesized MethodDef for the auto-destructor of a handle.
func SyntheticDestructor(handleName string) model.MethodDef {
	return model.MethodDef{
		Name: DestructorMethodName(handleName),
		Parameters: []model.ParameterDef{
			DestructorParam(handleName),
		},
	}
}
