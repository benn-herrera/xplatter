# Generated by xplatter dev on 2026-02-19 03:07:04 PST.
# This is a scaffold — customize as needed. Regeneration will not overwrite this file.

SHELL := /bin/bash
XPLATTER ?= ../../../xplatter.sh
API_DEF  := ../shared_specs/hello_xplatter.yaml
IMPL_LANG := c

API_NAME  := hello_xplatter
LIB_NAME  := libhello_xplatter
PASCAL_NAME := HelloXplatter
BUILD_MACRO := HELLO_XPLATTER_BUILD
BUILD_DIR := build
DIST_DIR  := dist
STAMP     := $(BUILD_DIR)/.generated

# ── Target filtering ──────────────────────────────────────────────────────────

TARGETS ?= ios android web desktop

target_enabled = $(filter $(1),$(TARGETS))

# ── Host platform detection ────────────────────────────────────────────────────

HOST_OS   := $(shell uname -s)
HOST_ARCH := $(shell uname -m)
EXE       :=
ifeq ($(HOST_OS),Darwin)
  DYLIB_EXT     := dylib
  NDK_HOST_OS   := darwin
  NDK_HOST_ARCH := x86_64
else ifneq (,$(findstring MINGW,$(HOST_OS))$(findstring MSYS,$(HOST_OS)))
  DYLIB_EXT     := dll
  NDK_HOST_OS   := windows
  NDK_HOST_ARCH := x86_64
  EXE           := .exe
else
  DYLIB_EXT    := so
  NDK_HOST_OS  := linux
  ifeq ($(HOST_ARCH),aarch64)
    NDK_HOST_ARCH := aarch64
  else
    NDK_HOST_ARCH := x86_64
  endif
endif
SHARED_LIB := $(BUILD_DIR)/$(LIB_NAME).$(DYLIB_EXT)

# ── MSVC discovery (Windows only) ─────────────────────────────────────────────
# If cl.exe is already on PATH (e.g. Developer Command Prompt), this is skipped.
# Otherwise, uses vswhere.exe to locate Visual Studio and sets up paths.
# Override MSVC_DIR to point to a custom MSVC toolset directory.

ifneq (,$(EXE))
  PROGRAMFILES_X86 ?= $(shell cmd //C "echo %ProgramFiles(x86)%" 2>/dev/null | tr -d '\r')
  VSWHERE := $(PROGRAMFILES_X86)/Microsoft Visual Studio/Installer/vswhere.exe
  ifeq (,$(shell which cl.exe 2>/dev/null))
    ifndef MSVC_DIR
      VS_PATH := $(shell "$(VSWHERE)" -latest -products '*' \
          -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 \
          -property installationPath -format value 2>/dev/null | tr -d '\r')
      MSVC_VER := $(shell cat "$(VS_PATH)/VC/Auxiliary/Build/Microsoft.VCToolsVersion.default.txt" 2>/dev/null | tr -d '\r')
      MSVC_DIR := $(VS_PATH)/VC/Tools/MSVC/$(MSVC_VER)
    endif
    MSVC_BIN  := $(MSVC_DIR)/bin/Hostx64/x64
    export PATH := $(MSVC_BIN);$(PATH)

    WIN_SDK_ROOT ?= $(PROGRAMFILES_X86)/Windows Kits/10
    WIN_SDK_VER  ?= $(shell ls "$(WIN_SDK_ROOT)/Include" 2>/dev/null | sort -V | tail -1)

    export INCLUDE := $(MSVC_DIR)/include;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/ucrt;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/shared;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/um
    export LIB := $(MSVC_DIR)/lib/x64;$(WIN_SDK_ROOT)/Lib/$(WIN_SDK_VER)/ucrt/x64;$(WIN_SDK_ROOT)/Lib/$(WIN_SDK_VER)/um/x64
  endif
endif

# ── NDK configuration ─────────────────────────────────────────────────────────

ifdef ANDROID_NDK
  NDK ?= $(ANDROID_NDK)
else
  ifndef ANDROID_SDK
    ifeq ($(NDK_HOST_OS),darwin)
      ANDROID_SDK ?= $(HOME)/Library/Android/sdk
    else ifeq ($(NDK_HOST_OS),linux)
      ANDROID_SDK ?= $(HOME)/Android/Sdk
    else ifeq ($(NDK_HOST_OS),windows)
      ANDROID_SDK ?= $(LOCALAPPDATA)/Android/Sdk
    endif
  endif
  NDK ?= $(shell ls $(ANDROID_SDK)/ndk | sort -V | tail -1)
endif
NDK_BIN         := $(NDK)/toolchains/llvm/prebuilt/$(NDK_HOST_OS)-$(NDK_HOST_ARCH)/bin
ANDROID_MIN_API := 28

# ── iOS ───────────────────────────────────────────────────────────────────────

IOS_MIN := 15.0

# ── Emscripten ────────────────────────────────────────────────────────────────

EMCC ?= emcc

# ── Generated binding files ───────────────────────────────────────────────────

GEN_DIR            := generated/
GEN_HEADER         := $(GEN_DIR)$(API_NAME).h
GEN_SWIFT_BINDING  := $(GEN_DIR)HelloXplatter.swift
GEN_KOTLIN_BINDING := $(GEN_DIR)HelloXplatter.kt
GEN_JS_BINDING     := $(GEN_DIR)$(API_NAME).js
GEN_JNI_SOURCE     := $(GEN_DIR)$(API_NAME)_jni.c

# ── WASM exports (computed from API definition) ──────────────────────────────

WASM_EXPORTS := ["_malloc","_free","_hello_xplatter_lifecycle_create_greeter","_hello_xplatter_lifecycle_destroy_greeter","_hello_xplatter_greeter_say_hello"]

# ── C build configuration ─────────────────────────────────────────────────────

PLATFORM_SERVICES := platform_services

ifneq (,$(EXE))
CC         := cl
CFLAGS     := /W4 /std:c17 /I. /I$(GEN_DIR) /D$(BUILD_MACRO)
LIB_VISIBILITY_FLAGS := /D$(BUILD_MACRO)
LIB_C_FLAGS := /std:c17 /W4 $(LIB_VISIBILITY_FLAGS)
else
CC         ?= cc
CFLAGS     := -Wall -Wextra -std=c17 -I. -I$(GEN_DIR)
LIB_VISIBILITY_FLAGS := -fvisibility=hidden -D$(BUILD_MACRO)
LIB_C_FLAGS := -std=c17 -Wall -Wextra $(LIB_VISIBILITY_FLAGS)
endif

# Cross-compilation flags (always GCC/Clang-style, for NDK + Emscripten)
CROSS_CFLAGS         := -Wall -Wextra -std=c17 -I. -I$(GEN_DIR)
CROSS_VISIBILITY     := -fvisibility=hidden -D$(BUILD_MACRO)
CROSS_LIB_C_FLAGS    := -std=c17 -Wall -Wextra $(CROSS_VISIBILITY)

# Ensure codegen runs before any target needs generated files
$(GEN_HEADER) $(GEN_SWIFT_BINDING) $(GEN_KOTLIN_BINDING) $(GEN_JS_BINDING) $(GEN_JNI_SOURCE): $(STAMP)

# ── Codegen ──────────────────────────────────────────────────────────────────

$(STAMP): $(API_DEF)
	@mkdir -p $(BUILD_DIR)
	$(XPLATTER) generate --impl-lang c -o generated $(API_DEF)
	@touch $@

.PHONY: test shared-lib clean

# ── Local build ──────────────────────────────────────────────────────────────

IMPL_SOURCES := $(API_NAME)_impl.c

test: $(STAMP)
	@mkdir -p $(BUILD_DIR)
ifneq (,$(EXE))
	$(CC) $(CFLAGS) /Fe:$(BUILD_DIR)/$(API_NAME).exe \
		$(IMPL_SOURCES) $(PLATFORM_SERVICES)/desktop.c test.c
else
	$(CC) $(CFLAGS) -o $(BUILD_DIR)/$(API_NAME) \
		$(IMPL_SOURCES) $(PLATFORM_SERVICES)/desktop.c test.c
endif
	./$(BUILD_DIR)/$(API_NAME)$(EXE)

shared-lib: $(SHARED_LIB)

$(SHARED_LIB): $(STAMP)
	@mkdir -p $(BUILD_DIR)
ifeq ($(HOST_OS),Darwin)
	$(CC) $(CFLAGS) $(LIB_VISIBILITY_FLAGS) -shared -fPIC \
		-Wl,-install_name,@rpath/$(LIB_NAME).$(DYLIB_EXT) \
		-o $@ $(IMPL_SOURCES) $(PLATFORM_SERVICES)/desktop.c
else ifneq (,$(EXE))
	$(CC) /LD $(LIB_VISIBILITY_FLAGS) $(CFLAGS) \
		$(IMPL_SOURCES) $(PLATFORM_SERVICES)/desktop.c \
		/Fe:$@ /link /IMPLIB:$(BUILD_DIR)/$(API_NAME).lib
else
	$(CC) $(CFLAGS) $(LIB_VISIBILITY_FLAGS) -shared -fPIC \
		-o $@ $(IMPL_SOURCES) $(PLATFORM_SERVICES)/desktop.c
endif

clean:
	rm -rf generated $(BUILD_DIR) $(DIST_DIR)

# ══════════════════════════════════════════════════════════════════════════════
# iOS: static libs per arch → lipo → xcframework + SPM package
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,ios),)
ifeq ($(HOST_OS),Darwin)

# $(1) = arch dir name, $(2) = clang target triple, $(3) = SDK name
define BUILD_IOS_ARCH

$(DIST_DIR)/ios/obj/$(1)/impl.o: $(IMPL_SOURCES) $(GEN_HEADER)
	@mkdir -p $$(dir $$@)
	xcrun --sdk $(3) clang $(CFLAGS) $(LIB_VISIBILITY_FLAGS) \
		-target $(2) -c -o $$@ $$<

$(DIST_DIR)/ios/obj/$(1)/platform.o: $(PLATFORM_SERVICES)/ios.c $(GEN_HEADER)
	@mkdir -p $$(dir $$@)
	xcrun --sdk $(3) clang $(LIB_C_FLAGS) \
		-target $(2) -c -o $$@ $$<

$(DIST_DIR)/ios/obj/$(1)/$(LIB_NAME).a: $(DIST_DIR)/ios/obj/$(1)/impl.o $(DIST_DIR)/ios/obj/$(1)/platform.o
	ar rcs $$@ $$^

endef

$(eval $(call BUILD_IOS_ARCH,ios-arm64,arm64-apple-ios$(IOS_MIN),iphoneos))
$(eval $(call BUILD_IOS_ARCH,ios-sim-arm64,arm64-apple-ios$(IOS_MIN)-simulator,iphonesimulator))
$(eval $(call BUILD_IOS_ARCH,ios-sim-x86_64,x86_64-apple-ios$(IOS_MIN)-simulator,iphonesimulator))

$(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a: $(DIST_DIR)/ios/obj/ios-sim-arm64/$(LIB_NAME).a $(DIST_DIR)/ios/obj/ios-sim-x86_64/$(LIB_NAME).a
	@mkdir -p $(dir $@)
	lipo -create $^ -output $@

$(DIST_DIR)/ios/headers/module.modulemap: $(GEN_HEADER)
	@mkdir -p $(DIST_DIR)/ios/headers
	cp $(GEN_HEADER) $(DIST_DIR)/ios/headers/
	printf 'module C$(PASCAL_NAME) {\n    header "$(API_NAME).h"\n    export *\n}\n' > $@

$(DIST_DIR)/ios/$(PASCAL_NAME).xcframework: $(DIST_DIR)/ios/obj/ios-arm64/$(LIB_NAME).a $(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a $(DIST_DIR)/ios/headers/module.modulemap
	rm -rf $@
	xcodebuild -create-xcframework \
		-library $(DIST_DIR)/ios/obj/ios-arm64/$(LIB_NAME).a -headers $(DIST_DIR)/ios/headers \
		-library $(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a -headers $(DIST_DIR)/ios/headers \
		-output $@

$(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Sources/$(PASCAL_NAME)Binding/$(PASCAL_NAME).swift: $(GEN_SWIFT_BINDING)
	@mkdir -p $(dir $@)
	awk '{print} /^import Foundation$$/{print "import C$(PASCAL_NAME)"}' $(GEN_SWIFT_BINDING) > $@

$(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Package.swift: $(DIST_DIR)/ios/$(PASCAL_NAME).xcframework
	@mkdir -p $(dir $@)
	printf '// swift-tools-version: 5.9\nimport PackageDescription\n\nlet package = Package(\n    name: "$(PASCAL_NAME)Lib",\n    platforms: [.iOS(.v15)],\n    products: [\n        .library(name: "$(PASCAL_NAME)Lib", targets: ["$(PASCAL_NAME)Binding"]),\n    ],\n    targets: [\n        .binaryTarget(name: "C$(PASCAL_NAME)", path: "../$(PASCAL_NAME).xcframework"),\n        .target(\n            name: "$(PASCAL_NAME)Binding",\n            dependencies: ["C$(PASCAL_NAME)"],\n            path: "Sources/$(PASCAL_NAME)Binding"\n        ),\n    ]\n)\n' > $@

.PHONY: package-ios
package-ios: $(DIST_DIR)/ios/$(PASCAL_NAME).xcframework $(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Package.swift $(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Sources/$(PASCAL_NAME)Binding/$(PASCAL_NAME).swift
	@echo "Packaged iOS: $(DIST_DIR)/ios/"

else

.PHONY: package-ios
package-ios:
	@echo "skipping iOS packaging on $(HOST_OS)"

endif
endif

# ══════════════════════════════════════════════════════════════════════════════
# Android: native libs per ABI + Kotlin binding + Gradle module
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,android),)

# $(1) = ABI name, $(2) = NDK target triple
define BUILD_ANDROID_ABI

$(DIST_DIR)/android/src/main/jniLibs/$(1)/$(LIB_NAME).so: $(IMPL_SOURCES) $(GEN_JNI_SOURCE) $(PLATFORM_SERVICES)/android.c $(GEN_HEADER)
	@mkdir -p $(DIST_DIR)/android/obj/$(1) $$(dir $$@)
	$(NDK_BIN)/$(2)-clang $(CROSS_CFLAGS) -fPIC $(CROSS_VISIBILITY) \
		-c -o $(DIST_DIR)/android/obj/$(1)/impl.o $(IMPL_SOURCES)
	$(NDK_BIN)/$(2)-clang $(CROSS_LIB_C_FLAGS) -fPIC \
		-c -o $(DIST_DIR)/android/obj/$(1)/jni.o $(GEN_JNI_SOURCE)
	$(NDK_BIN)/$(2)-clang $(CROSS_LIB_C_FLAGS) -fPIC \
		-c -o $(DIST_DIR)/android/obj/$(1)/platform.o $(PLATFORM_SERVICES)/android.c
	$(NDK_BIN)/$(2)-clang -shared -llog \
		$(DIST_DIR)/android/obj/$(1)/impl.o \
		$(DIST_DIR)/android/obj/$(1)/jni.o \
		$(DIST_DIR)/android/obj/$(1)/platform.o \
		-o $$@

endef

$(eval $(call BUILD_ANDROID_ABI,arm64-v8a,aarch64-linux-android$(ANDROID_MIN_API)))
$(eval $(call BUILD_ANDROID_ABI,armeabi-v7a,armv7a-linux-androideabi$(ANDROID_MIN_API)))
$(eval $(call BUILD_ANDROID_ABI,x86_64,x86_64-linux-android$(ANDROID_MIN_API)))
$(eval $(call BUILD_ANDROID_ABI,x86,i686-linux-android$(ANDROID_MIN_API)))

ANDROID_NATIVE_LIBS := \
	$(DIST_DIR)/android/src/main/jniLibs/arm64-v8a/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/armeabi-v7a/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/x86_64/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/x86/$(LIB_NAME).so

ANDROID_KOTLIN_PKG := $(subst _,/,$(API_NAME))

$(DIST_DIR)/android/src/main/kotlin/$(ANDROID_KOTLIN_PKG)/$(PASCAL_NAME).kt: $(GEN_KOTLIN_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_KOTLIN_BINDING) $@

$(DIST_DIR)/android/build.gradle.kts:
	@mkdir -p $(dir $@)
	printf 'plugins {\n    id("com.android.library")\n    id("org.jetbrains.kotlin.android")\n}\n\nandroid {\n    namespace = "$(subst _,.,$(API_NAME))"\n    compileSdk = 34\n    defaultConfig {\n        minSdk = $(ANDROID_MIN_API)\n    }\n}\n' > $@

$(DIST_DIR)/android/src/main/AndroidManifest.xml:
	@mkdir -p $(dir $@)
	printf '<?xml version="1.0" encoding="utf-8"?>\n<manifest />\n' > $@

.PHONY: package-android
package-android: $(ANDROID_NATIVE_LIBS) $(DIST_DIR)/android/src/main/kotlin/$(ANDROID_KOTLIN_PKG)/$(PASCAL_NAME).kt $(DIST_DIR)/android/build.gradle.kts $(DIST_DIR)/android/src/main/AndroidManifest.xml
	@echo "Packaged Android: $(DIST_DIR)/android/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Web: WASM + JS binding + package.json
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,web),)

$(DIST_DIR)/web/obj/impl.o: $(IMPL_SOURCES) $(GEN_HEADER)
	@mkdir -p $(dir $@)
	$(EMCC) $(CROSS_CFLAGS) -O2 $(CROSS_VISIBILITY) -c -o $@ $<

$(DIST_DIR)/web/obj/platform.o: $(PLATFORM_SERVICES)/web.c
	@mkdir -p $(dir $@)
	$(EMCC) $(CROSS_LIB_C_FLAGS) -O2 -c -o $@ $<

$(DIST_DIR)/web/$(API_NAME).wasm: $(DIST_DIR)/web/obj/impl.o $(DIST_DIR)/web/obj/platform.o
	$(EMCC) -o $@ $^ \
		--no-entry \
		-s 'EXPORTED_FUNCTIONS=$(WASM_EXPORTS)' \
		-s STANDALONE_WASM \
		-O2

$(DIST_DIR)/web/$(API_NAME).js: $(GEN_JS_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_JS_BINDING) $@

$(DIST_DIR)/web/package.json:
	@mkdir -p $(dir $@)
	printf '{\n  "name": "$(API_NAME)",\n  "version": "0.1.0",\n  "type": "module",\n  "main": "$(API_NAME).js"\n}\n' > $@

.PHONY: package-web
package-web: $(DIST_DIR)/web/$(API_NAME).wasm $(DIST_DIR)/web/$(API_NAME).js $(DIST_DIR)/web/package.json
	@echo "Packaged Web: $(DIST_DIR)/web/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Desktop: C header + Swift binding + shared library
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,desktop),)

$(DIST_DIR)/desktop/include/$(API_NAME).h: $(GEN_HEADER)
	@mkdir -p $(dir $@)
	cp $(GEN_HEADER) $@

$(DIST_DIR)/desktop/include/$(PASCAL_NAME).swift: $(GEN_SWIFT_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_SWIFT_BINDING) $@

$(DIST_DIR)/desktop/lib/$(LIB_NAME).$(DYLIB_EXT): $(SHARED_LIB)
	@mkdir -p $(dir $@)
	cp $(SHARED_LIB) $@

.PHONY: package-desktop
package-desktop: $(STAMP) $(DIST_DIR)/desktop/include/$(API_NAME).h $(DIST_DIR)/desktop/include/$(PASCAL_NAME).swift $(DIST_DIR)/desktop/lib/$(LIB_NAME).$(DYLIB_EXT)
	@echo "Packaged Desktop: $(DIST_DIR)/desktop/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Aggregate targets
# ══════════════════════════════════════════════════════════════════════════════

PACKAGE_TARGETS :=
ifneq ($(call target_enabled,ios),)
PACKAGE_TARGETS += package-ios
endif
ifneq ($(call target_enabled,android),)
PACKAGE_TARGETS += package-android
endif
ifneq ($(call target_enabled,web),)
PACKAGE_TARGETS += package-web
endif
ifneq ($(call target_enabled,desktop),)
PACKAGE_TARGETS += package-desktop
endif

.PHONY: packages build
packages: $(PACKAGE_TARGETS)
build: packages
