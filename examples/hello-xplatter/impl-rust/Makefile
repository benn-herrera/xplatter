# Generated by xplatter dev on 2026-02-19 03:06:44 PST.
# This is a scaffold — customize as needed. Regeneration will not overwrite this file.

SHELL := /bin/bash
XPLATTER ?= ../../../xplatter.sh
API_DEF  := ../shared_specs/hello_xplatter.yaml
IMPL_LANG := rust

API_NAME  := hello_xplatter
LIB_NAME  := libhello_xplatter
PASCAL_NAME := HelloXplatter
BUILD_MACRO := HELLO_XPLATTER_BUILD
BUILD_DIR := build
DIST_DIR  := dist
STAMP     := $(BUILD_DIR)/.generated

# ── Target filtering ──────────────────────────────────────────────────────────

TARGETS ?= ios android web desktop

target_enabled = $(filter $(1),$(TARGETS))

# ── Host platform detection ────────────────────────────────────────────────────

HOST_OS   := $(shell uname -s)
HOST_ARCH := $(shell uname -m)
EXE       :=
NDK_CMD	  :=
ifeq ($(HOST_OS),Darwin)
  DYLIB_EXT     := dylib
  NDK_HOST_OS   := darwin
  NDK_HOST_ARCH := x86_64
else ifneq (,$(findstring MINGW,$(HOST_OS))$(findstring MSYS,$(HOST_OS)))
  DYLIB_EXT     := dll
  NDK_HOST_OS   := windows
  NDK_HOST_ARCH := x86_64
  EXE           := .exe
  NDK_CMD		:= .cmd
else
  DYLIB_EXT    := so
  NDK_HOST_OS  := linux
  ifeq ($(HOST_ARCH),aarch64)
    NDK_HOST_ARCH := aarch64
  else
    NDK_HOST_ARCH := x86_64
  endif
endif
SHARED_LIB := $(BUILD_DIR)/$(LIB_NAME).$(DYLIB_EXT)

# ── MSVC discovery (Windows only) ─────────────────────────────────────────────
# If cl.exe is already on PATH (e.g. Developer Command Prompt), this is skipped.
# Otherwise, uses vswhere.exe to locate Visual Studio and sets up paths.
# Override MSVC_DIR to point to a custom MSVC toolset directory.

ifneq (,$(EXE))
  PROGRAMFILES_X86 ?= $(shell cmd //C "echo %ProgramFiles(x86)%" 2>/dev/null | tr -d '\r')
  VSWHERE := $(PROGRAMFILES_X86)/Microsoft Visual Studio/Installer/vswhere.exe
  ifeq (,$(shell which cl.exe 2>/dev/null))
    ifndef MSVC_DIR
      VS_PATH := $(shell "$(VSWHERE)" -latest -products '*' \
          -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 \
          -property installationPath -format value 2>/dev/null | tr -d '\r')
      MSVC_VER := $(shell cat "$(VS_PATH)/VC/Auxiliary/Build/Microsoft.VCToolsVersion.default.txt" 2>/dev/null | tr -d '\r')
      MSVC_DIR := $(VS_PATH)/VC/Tools/MSVC/$(MSVC_VER)
    endif
    MSVC_BIN  := $(MSVC_DIR)/bin/Hostx64/x64
    export PATH := $(MSVC_BIN);$(PATH)

    WIN_SDK_ROOT ?= $(PROGRAMFILES_X86)/Windows Kits/10
    WIN_SDK_VER  ?= $(shell ls "$(WIN_SDK_ROOT)/Include" 2>/dev/null | sort -V | tail -1)

    export INCLUDE := $(MSVC_DIR)/include;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/ucrt;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/shared;$(WIN_SDK_ROOT)/Include/$(WIN_SDK_VER)/um
    export LIB := $(MSVC_DIR)/lib/x64;$(WIN_SDK_ROOT)/Lib/$(WIN_SDK_VER)/ucrt/x64;$(WIN_SDK_ROOT)/Lib/$(WIN_SDK_VER)/um/x64
  endif
endif

# ── NDK configuration ─────────────────────────────────────────────────────────
# ANDK/ASDK normalize backslashes to forward slashes for Windows compatibility.

ifdef ANDROID_NDK
  ANDK ?= $(shell echo "$(ANDROID_NDK)" | sed 's:\\\\:/:g')
else
  ifdef ANDROID_SDK
    ASDK ?= $(shell echo "$(ANDROID_SDK)" | sed 's:\\\\:/:g')
  else
    ifeq ($(NDK_HOST_OS),darwin)
      ASDK ?= $(HOME)/Library/Android/sdk
    else ifeq ($(NDK_HOST_OS),linux)
      ASDK ?= $(HOME)/Android/Sdk
    else ifeq ($(NDK_HOST_OS),windows)
      ASDK ?= $(shell echo "$(LOCALAPPDATA)" | sed 's:\\:/:g')/Android/Sdk
    endif
  endif
  ANDK ?= $(shell ls -d $(ASDK)/ndk/* | sort -V | tail -1)
endif
NDK_BIN         := $(ANDK)/toolchains/llvm/prebuilt/$(NDK_HOST_OS)-$(NDK_HOST_ARCH)/bin
ANDROID_MIN_API := 28

# ── iOS ───────────────────────────────────────────────────────────────────────

IOS_MIN := 15.0

# ── Emscripten ────────────────────────────────────────────────────────────────

EMCC ?= emcc

# ── Generated binding files ───────────────────────────────────────────────────

GEN_DIR            := generated/
GEN_HEADER         := $(GEN_DIR)$(API_NAME).h
GEN_SWIFT_BINDING  := $(GEN_DIR)HelloXplatter.swift
GEN_KOTLIN_BINDING := $(GEN_DIR)HelloXplatter.kt
GEN_JS_BINDING     := $(GEN_DIR)$(API_NAME).js
GEN_JNI_SOURCE     := $(GEN_DIR)$(API_NAME)_jni.c

# ── WASM exports (computed from API definition) ──────────────────────────────

WASM_EXPORTS := ["_malloc","_free","_hello_xplatter_lifecycle_create_greeter","_hello_xplatter_lifecycle_destroy_greeter","_hello_xplatter_greeter_say_hello"]

# Ensure codegen runs before any target needs generated files
$(GEN_HEADER) $(GEN_SWIFT_BINDING) $(GEN_KOTLIN_BINDING) $(GEN_JS_BINDING) $(GEN_JNI_SOURCE): $(STAMP)

CROSS_LIB_C_FLAGS := -std=c17 -Wall -Wextra -fvisibility=hidden -D$(BUILD_MACRO)

# ── Codegen ──────────────────────────────────────────────────────────────────

$(STAMP): $(API_DEF)
	@mkdir -p $(BUILD_DIR)
	$(XPLATTER) generate --impl-lang rust -o generated $(API_DEF)
	@touch $@

.PHONY: test shared-lib clean

test: $(STAMP)
	cargo test

shared-lib: $(SHARED_LIB)

$(SHARED_LIB): $(STAMP)
	cargo build --release
	@mkdir -p $(BUILD_DIR)
ifneq (,$(EXE))
	cp target/release/$(API_NAME).dll $(SHARED_LIB)
else ifeq ($(HOST_OS),Darwin)
	cp target/release/$(LIB_NAME).$(DYLIB_EXT) $(SHARED_LIB)
	install_name_tool -id @rpath/$(LIB_NAME).$(DYLIB_EXT) $(SHARED_LIB)
else
	cp target/release/$(LIB_NAME).$(DYLIB_EXT) $(SHARED_LIB)
endif

clean:
	cargo clean
	rm -rf generated $(BUILD_DIR) $(DIST_DIR) flatbuffers

# ══════════════════════════════════════════════════════════════════════════════
# iOS: static libs per arch → lipo → xcframework + SPM package
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,ios),)
ifeq ($(HOST_OS),Darwin)

# $(1) = arch dir name, $(2) = Rust target triple
define BUILD_IOS_ARCH

$(DIST_DIR)/ios/obj/$(1)/$(LIB_NAME).a: $(STAMP)
	@mkdir -p $$(dir $$@)
	cargo build --release --target $(2)
	cp target/$(2)/release/$(LIB_NAME).a $$@

endef

$(eval $(call BUILD_IOS_ARCH,ios-arm64,aarch64-apple-ios))
$(eval $(call BUILD_IOS_ARCH,ios-sim-arm64,aarch64-apple-ios-sim))
$(eval $(call BUILD_IOS_ARCH,ios-sim-x86_64,x86_64-apple-ios))

$(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a: $(DIST_DIR)/ios/obj/ios-sim-arm64/$(LIB_NAME).a $(DIST_DIR)/ios/obj/ios-sim-x86_64/$(LIB_NAME).a
	@mkdir -p $(dir $@)
	lipo -create $^ -output $@

$(DIST_DIR)/ios/headers/module.modulemap: $(GEN_HEADER)
	@mkdir -p $(DIST_DIR)/ios/headers
	cp $(GEN_HEADER) $(DIST_DIR)/ios/headers/
	printf 'module C$(PASCAL_NAME) {\n    header "$(API_NAME).h"\n    export *\n}\n' > $@

$(DIST_DIR)/ios/$(PASCAL_NAME).xcframework: $(DIST_DIR)/ios/obj/ios-arm64/$(LIB_NAME).a $(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a $(DIST_DIR)/ios/headers/module.modulemap
	rm -rf $@
	xcodebuild -create-xcframework \
		-library $(DIST_DIR)/ios/obj/ios-arm64/$(LIB_NAME).a -headers $(DIST_DIR)/ios/headers \
		-library $(DIST_DIR)/ios/obj/ios-sim-fat/$(LIB_NAME).a -headers $(DIST_DIR)/ios/headers \
		-output $@

$(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Sources/$(PASCAL_NAME)Binding/$(PASCAL_NAME).swift: $(GEN_SWIFT_BINDING)
	@mkdir -p $(dir $@)
	awk '{print} /^import Foundation$$/{print "import C$(PASCAL_NAME)"}' $(GEN_SWIFT_BINDING) > $@

$(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Package.swift: $(DIST_DIR)/ios/$(PASCAL_NAME).xcframework
	@mkdir -p $(dir $@)
	printf '// swift-tools-version: 5.9\nimport PackageDescription\n\nlet package = Package(\n    name: "$(PASCAL_NAME)Lib",\n    platforms: [.iOS(.v15)],\n    products: [\n        .library(name: "$(PASCAL_NAME)Lib", targets: ["$(PASCAL_NAME)Binding"]),\n    ],\n    targets: [\n        .binaryTarget(name: "C$(PASCAL_NAME)", path: "../$(PASCAL_NAME).xcframework"),\n        .target(\n            name: "$(PASCAL_NAME)Binding",\n            dependencies: ["C$(PASCAL_NAME)"],\n            path: "Sources/$(PASCAL_NAME)Binding"\n        ),\n    ]\n)\n' > $@

.PHONY: package-ios
package-ios: $(DIST_DIR)/ios/$(PASCAL_NAME).xcframework $(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Package.swift $(DIST_DIR)/ios/$(PASCAL_NAME)Lib/Sources/$(PASCAL_NAME)Binding/$(PASCAL_NAME).swift
	@echo "Packaged iOS: $(DIST_DIR)/ios/"

else

.PHONY: package-ios
package-ios:
	@echo "skipping iOS packaging on $(HOST_OS)"

endif
endif

# ══════════════════════════════════════════════════════════════════════════════
# Android: native libs per ABI + Kotlin binding + Gradle module
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,android),)

# $(1) = ABI name, $(2) = Rust target triple, $(3) = NDK target prefix, $(4) = uppercase Cargo target
define BUILD_ANDROID_ABI

$(DIST_DIR)/android/src/main/jniLibs/$(1)/$(LIB_NAME).so: $(STAMP)
	@mkdir -p $(DIST_DIR)/android/obj/$(1) $$(dir $$@)
	CARGO_TARGET_$(4)_LINKER="$(NDK_BIN)/$(3)-clang$(NDK_CMD)" \
		PATH=$(NDK_BIN):$$$$PATH cargo build --release --target $(2)
	"$(NDK_BIN)/$(3)-clang" $(CROSS_LIB_C_FLAGS) -fPIC \
		-Igenerated -c -o $(DIST_DIR)/android/obj/$(1)/jni.o $(GEN_JNI_SOURCE)
	"$(NDK_BIN)/$(3)-clang" -shared \
		-Wl,--whole-archive target/$(2)/release/$(LIB_NAME).a -Wl,--no-whole-archive \
		$(DIST_DIR)/android/obj/$(1)/jni.o \
		-ldl -lm -llog \
		-o $$@

endef

$(eval $(call BUILD_ANDROID_ABI,arm64-v8a,aarch64-linux-android,aarch64-linux-android$(ANDROID_MIN_API),AARCH64_LINUX_ANDROID))
$(eval $(call BUILD_ANDROID_ABI,armeabi-v7a,armv7-linux-androideabi,armv7a-linux-androideabi$(ANDROID_MIN_API),ARMV7_LINUX_ANDROIDEABI))
$(eval $(call BUILD_ANDROID_ABI,x86_64,x86_64-linux-android,x86_64-linux-android$(ANDROID_MIN_API),X86_64_LINUX_ANDROID))
$(eval $(call BUILD_ANDROID_ABI,x86,i686-linux-android,i686-linux-android$(ANDROID_MIN_API),I686_LINUX_ANDROID))

ANDROID_NATIVE_LIBS := \
	$(DIST_DIR)/android/src/main/jniLibs/arm64-v8a/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/armeabi-v7a/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/x86_64/$(LIB_NAME).so \
	$(DIST_DIR)/android/src/main/jniLibs/x86/$(LIB_NAME).so

ANDROID_KOTLIN_PKG := $(subst _,/,$(API_NAME))

$(DIST_DIR)/android/src/main/kotlin/$(ANDROID_KOTLIN_PKG)/$(PASCAL_NAME).kt: $(GEN_KOTLIN_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_KOTLIN_BINDING) $@

$(DIST_DIR)/android/build.gradle.kts:
	@mkdir -p $(dir $@)
	printf 'plugins {\n    id("com.android.library")\n    id("org.jetbrains.kotlin.android")\n}\n\nandroid {\n    namespace = "$(subst _,.,$(API_NAME))"\n    compileSdk = 34\n    defaultConfig {\n        minSdk = $(ANDROID_MIN_API)\n    }\n}\n' > $@

$(DIST_DIR)/android/src/main/AndroidManifest.xml:
	@mkdir -p $(dir $@)
	printf '<?xml version="1.0" encoding="utf-8"?>\n<manifest />\n' > $@

.PHONY: package-android
package-android: $(ANDROID_NATIVE_LIBS) $(DIST_DIR)/android/src/main/kotlin/$(ANDROID_KOTLIN_PKG)/$(PASCAL_NAME).kt $(DIST_DIR)/android/build.gradle.kts $(DIST_DIR)/android/src/main/AndroidManifest.xml
	@echo "Packaged Android: $(DIST_DIR)/android/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Web: WASM + JS binding + package.json
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,web),)

$(DIST_DIR)/web/$(API_NAME).wasm: $(STAMP)
	@mkdir -p $(dir $@)
	cargo build --release --target wasm32-unknown-unknown
	cp target/wasm32-unknown-unknown/release/$(shell echo $(API_NAME) | tr '-' '_').wasm $@

$(DIST_DIR)/web/$(API_NAME).js: $(GEN_JS_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_JS_BINDING) $@

$(DIST_DIR)/web/package.json:
	@mkdir -p $(dir $@)
	printf '{\n  "name": "$(API_NAME)",\n  "version": "0.1.0",\n  "type": "module",\n  "main": "$(API_NAME).js"\n}\n' > $@

.PHONY: package-web
package-web: $(DIST_DIR)/web/$(API_NAME).wasm $(DIST_DIR)/web/$(API_NAME).js $(DIST_DIR)/web/package.json
	@echo "Packaged Web: $(DIST_DIR)/web/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Desktop: C header + Swift binding + shared library
# ══════════════════════════════════════════════════════════════════════════════

ifneq ($(call target_enabled,desktop),)

$(DIST_DIR)/desktop/include/$(API_NAME).h: $(GEN_HEADER)
	@mkdir -p $(dir $@)
	cp $(GEN_HEADER) $@

$(DIST_DIR)/desktop/include/$(PASCAL_NAME).swift: $(GEN_SWIFT_BINDING)
	@mkdir -p $(dir $@)
	cp $(GEN_SWIFT_BINDING) $@

$(DIST_DIR)/desktop/lib/$(LIB_NAME).$(DYLIB_EXT): $(SHARED_LIB)
	@mkdir -p $(dir $@)
	cp $(SHARED_LIB) $@

.PHONY: package-desktop
package-desktop: $(STAMP) $(DIST_DIR)/desktop/include/$(API_NAME).h $(DIST_DIR)/desktop/include/$(PASCAL_NAME).swift $(DIST_DIR)/desktop/lib/$(LIB_NAME).$(DYLIB_EXT)
	@echo "Packaged Desktop: $(DIST_DIR)/desktop/"

endif

# ══════════════════════════════════════════════════════════════════════════════
# Aggregate targets
# ══════════════════════════════════════════════════════════════════════════════

PACKAGE_TARGETS :=
ifneq ($(call target_enabled,ios),)
PACKAGE_TARGETS += package-ios
endif
ifneq ($(call target_enabled,android),)
PACKAGE_TARGETS += package-android
endif
ifneq ($(call target_enabled,web),)
PACKAGE_TARGETS += package-web
endif
ifneq ($(call target_enabled,desktop),)
PACKAGE_TARGETS += package-desktop
endif

.PHONY: packages build
packages: $(PACKAGE_TARGETS)
build: packages
