// hello_xplatter v0.1.0 â€” JavaScript/WASM binding
// Generated by xplatter. Do not edit.

const _encoder = new TextEncoder();
const _decoder = new TextDecoder();

let _wasm = null;

// Memory management helpers
function _malloc(size) {
  return _wasm.exports.malloc(size);
}

function _free(ptr) {
  _wasm.exports.free(ptr);
}

function _memoryBuffer() {
  return _wasm.exports.memory.buffer;
}

// String marshalling
function _encodeString(str) {
  const bytes = _encoder.encode(str);
  const ptr = _malloc(bytes.length + 1);
  const dest = new Uint8Array(_memoryBuffer(), ptr, bytes.length + 1);
  dest.set(bytes);
  dest[bytes.length] = 0;
  return ptr;
}

function _decodeString(ptr) {
  const mem = new Uint8Array(_memoryBuffer());
  let end = ptr;
  while (mem[end] !== 0) end++;
  return _decoder.decode(mem.subarray(ptr, end));
}

// Buffer marshalling
function _copyBufferToWasm(typedArray) {
  const bytes = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
  const ptr = _malloc(bytes.length);
  const dest = new Uint8Array(_memoryBuffer(), ptr, bytes.length);
  dest.set(bytes);
  return [ptr, typedArray.length];
}

function _readBufferFromWasm(ptr, length, TypedArrayCtor) {
  const byteSize = length * TypedArrayCtor.BYTES_PER_ELEMENT;
  const src = new Uint8Array(_memoryBuffer(), ptr, byteSize);
  const result = new TypedArrayCtor(length);
  new Uint8Array(result.buffer).set(src);
  return result;
}

// Handle wrapper classes
class Greeter {
  #ptr;

  /** @internal */
  constructor(ptr) {
    this.#ptr = ptr;
  }

  /** @internal */
  get _ptr() {
    if (this.#ptr === 0) {
      throw new Error('Greeter has been disposed');
    }
    return this.#ptr;
  }

  dispose() {
    this.#ptr = 0;
  }

  close() {
    this.dispose();
  }

  [Symbol.dispose]() {
    this.dispose();
  }
}

// Minimal WASI snapshot_preview1 polyfill
// Required for GOOS=wasip1 WASM modules (e.g. Go). Harmless for others.
function _buildWasiImports() {
  const ERRNO_SUCCESS = 0;
  const ERRNO_BADF    = 8;
  const ERRNO_NOSYS   = 52;
  return {
    fd_write(fd, iovsPtr, iovsLen, nwrittenPtr) {
      const mem  = _memoryBuffer();
      const view = new DataView(mem);
      let written = 0;
      for (let i = 0; i < iovsLen; i++) {
        const base = iovsPtr + i * 8;
        const ptr  = view.getUint32(base,     true);
        const len  = view.getUint32(base + 4, true);
        if (len > 0 && (fd === 1 || fd === 2)) {
          const text = new TextDecoder().decode(new Uint8Array(mem, ptr, len));
          (fd === 2 ? console.error : console.log)(text.replace(/\n$/, ''));
        }
        written += len;
      }
      view.setUint32(nwrittenPtr, written, true);
      return ERRNO_SUCCESS;
    },
    fd_read:            () => ERRNO_NOSYS,
    fd_seek:            () => ERRNO_NOSYS,
    fd_close:           () => ERRNO_SUCCESS,
    fd_fdstat_get:      () => ERRNO_NOSYS,
    fd_fdstat_set_flags:() => ERRNO_NOSYS,
    fd_prestat_get:     () => ERRNO_BADF,
    fd_prestat_dir_name:() => ERRNO_BADF,
    path_open:          () => ERRNO_NOSYS,
    path_filestat_get:  () => ERRNO_NOSYS,
    environ_sizes_get(countPtr, bufSizePtr) {
      const v = new DataView(_memoryBuffer());
      v.setUint32(countPtr,   0, true);
      v.setUint32(bufSizePtr, 0, true);
      return ERRNO_SUCCESS;
    },
    environ_get(environPtr) {
      new DataView(_memoryBuffer()).setUint32(environPtr, 0, true);
      return ERRNO_SUCCESS;
    },
    args_sizes_get(argcPtr, bufSizePtr) {
      const v = new DataView(_memoryBuffer());
      v.setUint32(argcPtr,    0, true);
      v.setUint32(bufSizePtr, 0, true);
      return ERRNO_SUCCESS;
    },
    args_get(argvPtr) {
      new DataView(_memoryBuffer()).setUint32(argvPtr, 0, true);
      return ERRNO_SUCCESS;
    },
    proc_exit: (code) => {
      const e = new Error('proc_exit:' + code);
      e.wasiExitCode = code;
      throw e;
    },
    random_get(bufPtr, bufLen) {
      crypto.getRandomValues(new Uint8Array(_memoryBuffer(), bufPtr, bufLen));
      return ERRNO_SUCCESS;
    },
    clock_time_get(_clockId, _precision, timePtr) {
      const ns = BigInt(Date.now()) * 1_000_000n;
      new DataView(_memoryBuffer()).setBigUint64(timePtr, ns, true);
      return ERRNO_SUCCESS;
    },
    clock_res_get(_clockId, resPtr) {
      new DataView(_memoryBuffer()).setBigUint64(resPtr, 1_000_000n, true);
      return ERRNO_SUCCESS;
    },
    sched_yield:  () => ERRNO_SUCCESS,
    poll_oneoff:  () => ERRNO_NOSYS,
    sock_accept:  () => ERRNO_NOSYS,
    sock_recv:    () => ERRNO_NOSYS,
    sock_send:    () => ERRNO_NOSYS,
    sock_shutdown:() => ERRNO_NOSYS,
  };
}

// Platform service WASM imports
function _buildPlatformImports(services) {
  services = services || {};
  return {
    env: {
      hello_xplatter_log_sink: (level, tagPtr, msgPtr) => {
        if (services.logSink) {
          services.logSink(level, _decodeString(tagPtr), _decodeString(msgPtr));
        }
      },
      hello_xplatter_resource_count: () => {
        return services.resourceCount ? services.resourceCount() : 0;
      },
      hello_xplatter_resource_name: (index, bufferPtr, bufferSize) => {
        if (!services.resourceName) return -1;
        const name = services.resourceName(index);
        if (!name) return -1;
        const bytes = _encoder.encode(name);
        if (bytes.length + 1 > bufferSize) return -1;
        const dest = new Uint8Array(_memoryBuffer(), bufferPtr, bufferSize);
        dest.set(bytes);
        dest[bytes.length] = 0;
        return bytes.length;
      },
      hello_xplatter_resource_exists: (namePtr) => {
        if (!services.resourceExists) return 0;
        return services.resourceExists(_decodeString(namePtr)) ? 1 : 0;
      },
      hello_xplatter_resource_size: (namePtr) => {
        if (!services.resourceSize) return 0;
        return services.resourceSize(_decodeString(namePtr));
      },
      hello_xplatter_resource_read: (namePtr, bufferPtr, bufferSize) => {
        if (!services.resourceRead) return -1;
        const data = services.resourceRead(_decodeString(namePtr));
        if (!data || data.length > bufferSize) return -1;
        const dest = new Uint8Array(_memoryBuffer(), bufferPtr, bufferSize);
        dest.set(new Uint8Array(data.buffer || data));
        return data.length;
      },
    },
    wasi_snapshot_preview1: _buildWasiImports(),
  };
}

// WASM module loader
async function loadHelloXplatter(wasmSource, platformServices) {
  const imports = _buildPlatformImports(platformServices);
  let result;
  if (wasmSource instanceof WebAssembly.Module) {
    result = await WebAssembly.instantiate(wasmSource, imports);
    _wasm = { exports: result.exports };
  } else if (wasmSource instanceof Response || typeof wasmSource === 'string') {
    const response = typeof wasmSource === 'string' ? fetch(wasmSource) : wasmSource;
    result = await WebAssembly.instantiateStreaming(response, imports);
    _wasm = result.instance;
  } else if (wasmSource instanceof ArrayBuffer || ArrayBuffer.isView(wasmSource)) {
    const module = await WebAssembly.compile(wasmSource);
    result = await WebAssembly.instantiate(module, imports);
    _wasm = { exports: result.exports };
  } else {
    throw new Error('wasmSource must be a URL string, Response, WebAssembly.Module, or ArrayBuffer');
  }
  // Initialize WASM runtime.
  // Reactor mode (Rust, C/Emscripten): exports _initialize, returns normally.
  // Command mode (Go wasip1): exports _start, which runs main() then calls
  // proc_exit(0). proc_exit throws to unwind the stack; exit code 0 is success.
  if (_wasm.exports._initialize) {
    _wasm.exports._initialize();
  } else if (_wasm.exports._start) {
    try {
      _wasm.exports._start();
    } catch (e) {
      if (!e || e.wasiExitCode !== 0) throw e;
    }
  }
  return {
    lifecycle: _createLifecycle(),
    greeter: _createGreeter(),
  };
}

// lifecycle interface
function _createLifecycle() {
  return {
    createGreeter() {
      const _outPtr = _malloc(4);
      try {
        const _rc = _wasm.exports.hello_xplatter_lifecycle_create_greeter(_outPtr);
        if (_rc !== 0) {
          throw new Error(`createGreeter failed with error code ${_rc}`);
        }
        const _view = new DataView(_memoryBuffer());
        const _handleVal = _view.getUint32(_outPtr, true);
        return new Greeter(_handleVal);
      } finally {
        _free(_outPtr);
      }
    },

    destroyGreeter(greeter) {
      _wasm.exports.hello_xplatter_lifecycle_destroy_greeter(greeter._ptr);
    },
  };
}

// greeter interface
function _createGreeter() {
  return {
    sayHello(greeter, name) {
      const _namePtr = _encodeString(name);
      const _outPtr = _malloc(8);
      try {
        const _rc = _wasm.exports.hello_xplatter_greeter_say_hello(greeter._ptr, _namePtr, _outPtr);
        if (_rc !== 0) {
          throw new Error(`sayHello failed with error code ${_rc}`);
        }
        const _view = new DataView(_memoryBuffer());
        return { message: _decodeString(_view.getUint32(_outPtr + 0, true)), apiImpl: _decodeString(_view.getUint32(_outPtr + 4, true)) };
      } finally {
        _free(_namePtr);
        _free(_outPtr);
      }
    },
  };
}

// Exports
export { loadHelloXplatter };
export { Greeter };
